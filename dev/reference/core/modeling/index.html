<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modeling · Flight.jl</title><meta name="title" content="Modeling · Flight.jl"/><meta property="og:title" content="Modeling · Flight.jl"/><meta property="twitter:title" content="Modeling · Flight.jl"/><meta name="description" content="Documentation for Flight.jl."/><meta property="og:description" content="Documentation for Flight.jl."/><meta property="twitter:description" content="Documentation for Flight.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Flight.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../../tutorials/tutorial01/tutorial01/">Interactive Simulation</a></li><li><a class="tocitem" href="../../../tutorials/tutorial02/tutorial02/">Headless Simulation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modeling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/e271828e/Flight.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/e271828e/Flight.jl/blob/master/docs/src/reference/core/modeling.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Modeling"><a class="docs-heading-anchor" href="#Modeling">Modeling</a><a id="Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><h3 id="Philosophy:-Performance,-Control,-and-Transparency"><a class="docs-heading-anchor" href="#Philosophy:-Performance,-Control,-and-Transparency">Philosophy: Performance, Control, and Transparency</a><a id="Philosophy:-Performance,-Control,-and-Transparency-1"></a><a class="docs-heading-anchor-permalink" href="#Philosophy:-Performance,-Control,-and-Transparency" title="Permalink"></a></h3><p>The <code>Modeling</code> module is the cornerstone of <code>Flight.jl</code>. It provides a lightweight, flexible and high-performance framework, which enables creating complex systems from simpler, reusable components in a hierarchical fashion.</p><p>This modeling framework is <strong>causal</strong> and <strong>imperative</strong>. It is domain-agnostic by design, but it is tailored to / heavily oriented towards its primary goals: GNC algorithm development and real-time simulation.</p><p>It can be understood as a generalization of the classic state-space representation used in control engineering and other disciplines. Shares the same input, state, output, but generalized to accomodate nonlinear and discrete dynamics state-space oriented, which is a good fit for most tasks within the GNC domain</p><p>In essence, modeling.jl is not a symbolic modeling system; it is a framework for organizing imperative, state-space code into a composable hierarchy.</p><p>This framework was developed specifically to meet the requirements of guidance, navigation &amp; control applications. Its minimalistic design is a deliberate choice prioritizing <strong>ultimate performance, fine-grained control, and architectural transparency</strong>. absolute control</p><p>The user explicitly:</p><ul><li>Specifies the properties of each component: input, output, continuous state, etc.</li><li>Writes the Julia code within the update functions that define the system&#39;s dynamics.</li></ul><p>This approach places a greater responsibility on the user to achieve performant, efficient code. In return, it grants absolute control and predictability, which are desirable for real-time simulation and deep systems analysis.</p><p>This is different from the <strong>acausal</strong>, symbolic and declarative paradigm of modeling frameworks like <code>ModelingToolkit.jl</code>.</p><p>Its capabilities are less general</p><p>For the specific domain of real-time, high-fidelity aircraft GNC simulation, where the underlying physics are well-described by causal ODEs and performance is paramount, this is an excellent and highly justifiable engineering choice</p><p>favors</p><p>Do focus on what ModelingToolkit.jl is or is not. Focus on describing what Flight.jl does.</p><p>While Julia&#39;s ecosystem offers the powerful <code>ModelingToolkit.jl</code> (MTK) for acausal modeling, <code>Flight.jl</code> uses a custom, causal framework for several deliberate reasons that are critical to its design goals:</p><ol><li><p><strong>Guaranteed, Hand-Tuned Performance:</strong> The causal approach gives the developer absolute control  over the computational path in the performance-critical model update functions. This allows for  manual optimization to guarantee a type-stable, zero-allocation simulation loop, which is  essential for real-time applications and large-scale analysis.</p></li><li><p><strong>Intuitive for GNC Algorithm Design:</strong> The signal-flow paradigm is the natural mental model  for control engineers. The explicit definition of inputs, outputs, and discrete update logic  (<code>f_periodic!</code>) maps directly to the implementation of digital flight control and guidance  systems.</p></li><li><p><strong>Simplicity and Transparency:</strong> The framework&#39;s abstractions are simple and direct. A <code>Model</code>  is just a Julia <code>struct</code>, and its dynamics are just Julia functions. This makes the entire  system highly transparent and easy to debug with standard Julia tools.</p></li></ol><p>In summary, <code>Flight.jl</code>&#39;s modeling framework is a specialized tool designed for a specific job. It trades the generality and automatic code generation of symbolic systems for the raw performance, transparency, and control of a carefully crafted imperative structure.</p><p>State-space</p><p>Flight dynamics modeling tasks fit very well</p><p>This guide explains the core concepts of the framework and the &quot;performance contract&quot; you implicitly agree to when creating new components.</p><p><code>Flight.jl</code> employs a <strong>causal</strong> (or signal-flow) modeling paradigm. This means the flow of computation is explicitly defined by the developer. Every <code>Model</code> must adhere to a standardized interface of update functions that define its behavior:</p><p>In essence, <code>Flight.jl</code>&#39;s framework is not an attempt to reinvent a general-purpose modeling language. It is a specialized, domain-specific tool forged for the express purpose of building the most performant and flexible flight simulation systems possible in Julia.</p><h3 id="Core-Concepts:-Blueprints-and-Instances"><a class="docs-heading-anchor" href="#Core-Concepts:-Blueprints-and-Instances">Core Concepts: Blueprints and Instances</a><a id="Core-Concepts:-Blueprints-and-Instances-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Concepts:-Blueprints-and-Instances" title="Permalink"></a></h3><h3 id="The-ModelDefinition-/-Model-Paradigm"><a class="docs-heading-anchor" href="#The-ModelDefinition-/-Model-Paradigm">The <code>ModelDefinition</code> / <code>Model</code> Paradigm</a><a id="The-ModelDefinition-/-Model-Paradigm-1"></a><a class="docs-heading-anchor-permalink" href="#The-ModelDefinition-/-Model-Paradigm" title="Permalink"></a></h3><p>The framework is built upon two core abstractions:</p><h4 id="1.-ModelDefinition:-The-Static-Blueprint"><a class="docs-heading-anchor" href="#1.-ModelDefinition:-The-Static-Blueprint">1. <code>ModelDefinition</code>: The Static Blueprint</a><a id="1.-ModelDefinition:-The-Static-Blueprint-1"></a><a class="docs-heading-anchor-permalink" href="#1.-ModelDefinition:-The-Static-Blueprint" title="Permalink"></a></h4><p>A <code>ModelDefinition</code> is a <code>struct</code> that acts as a <strong>blueprint</strong> for a simulation component. Its purpose is to:</p><ol><li><p>Define the static parameters and constants of the component.</p></li><li><p>Establish the system&#39;s hierarchy by including other <code>ModelDefinition</code>s as fields.</p><p>For example, a <code>Vehicle</code> is <em>defined</em> as having <code>Systems</code>, <code>Kinematics</code>, and <code>Dynamics</code> components:</p><p>```julia</p><h1>A simplified conceptual example</h1><p>struct Vehicle &lt;: ModelDefinition      systems::Systems   #&lt;– Child ModelDefinition      kinematics::WA     #&lt;– Child ModelDefinition      dynamics::VehicleDynamics  end  ```</p><p><code>ModelDefinition</code>s are lightweight, compile-time constructs that describe the structure of your  simulation.</p></li></ol><ol><li><p><strong><code>ModelDefinition</code> (The Blueprint):</strong> An abstract type for user-defined <code>struct</code>s that serve as  a declarative blueprint for a system component. A <code>ModelDefinition</code> specifies a component&#39;s  constant parameters and its hierarchical structure by including other <code>ModelDefinition</code>s as  fields.</p><p>```julia  using Flight.FlightCore # Assuming this is where Modeling is exported</p><p>struct MyActuator &lt;: ModelDefinition      τ::Float64 #A constant parameter (time constant)  end</p><p>struct MyAircraft &lt;: ModelDefinition      actuator::MyActuator #A sub-component      mass::Float64 #Another constant parameter  end  ```</p></li><li><p><strong><code>Model</code> (The Instance):</strong> The concrete, stateful object used by the simulation engine. When a  <code>ModelDefinition</code> is passed to the <code>Model</code> constructor, it recursively builds a tree of <code>Model</code>  instances and allocates the necessary memory for its state, inputs, and outputs.</p><p><code>julia  aircraft_def = MyAircraft(actuator = MyActuator(τ = 0.1), mass = 1000.0)  aircraft_model = Model(aircraft_def)</code></p></li></ol><p>A <code>Model</code> is the <strong>stateful instance</strong> of a component used during the simulation. It is created by passing a <code>ModelDefinition</code> to the <code>Model</code> constructor: <code>mdl = Model(my_definition)</code>. The <code>Model</code> struct holds the &quot;live&quot; data: Every <code>Model</code> instance in the simulation holds five key properties:</p><ul><li><code>x</code>: The <strong>continuous state</strong> vector, which is managed by the ODE solver.</li><li><code>ẋ</code>: The <strong>continuous state derivative</strong>, which is computed by the model&#39;s dynamics.</li><li><code>s</code>: The <strong>discrete state</strong>, a mutable <code>struct</code> for states that change at discrete time   instances.</li><li><code>u</code>: The <strong>input</strong>, a mutable data type for variables that are assigned externally.</li><li><code>y</code>: The <strong>output</strong>, an immutable data type holding the results of the <code>Model</code>&#39;s computations.</li></ul><p>When a <code>Model</code> is created, the framework recursively constructs <code>Model</code> instances for all its children, creating a tree of interconnected objects. <code>ComponentArrays</code> are used under the hood to ensure that the state vector <code>x</code> of a parent <code>Model</code> is a single, contiguous block of memory composed of the state vectors of its children. This is so that the ODE solver sees the continuous state vector and its derivative as a single, contiguous blocks of memory.</p><h2 id="How-to-define-a-Model&#39;s-X,-Xdot,-S,-U,-Y"><a class="docs-heading-anchor" href="#How-to-define-a-Model&#39;s-X,-Xdot,-S,-U,-Y">How to define a Model&#39;s X, Xdot, S, U, Y</a><a id="How-to-define-a-Model&#39;s-X,-Xdot,-S,-U,-Y-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-define-a-Model&#39;s-X,-Xdot,-S,-U,-Y" title="Permalink"></a></h2><p>The <code>ModelDefinition</code> struct itself contains fields that are either <code>ModelDefinition</code> subtypes or other types. These end up as <code>parameters</code> and <code>submodels</code> respectively. But, how do you specify the <code>Model</code>&#39;s <code>x</code>, <code>xdot</code>, etc?</p><p>By default, all of these <code>Model</code> properties will be <code>nothing</code>. The only exception is x and x_dot for a node (non-leaf) <code>Model</code>. To specify what you want them to be, you define constructor methods for each of these <code>ModelDescriptor</code>s that dispatch on your <code>ModelDefinition</code> subtype. This sounds more complicated than it is. An example: Let&#39;s say we want</p><p>The only exception is x and x_dot for a node (non-leaf) Model. You typically should not define Modeling.X for such models. Their x and x dot will be automatically assembled from those of its children, and they will share memory with them.</p><pre><code class="nohighlight hljs">struct MyDef &lt;: ModelDefinition end

Modeling.X(::MyDef) = zeros(3) #must be an AbstractVector
Modeling.Y(::MyDef) = zeros(SVector{3}) #must be an isbits type
Modeling.U(::MyDef) = Ref(0.0) #can be any mutable type

mdl = MyDef() |&gt; Model
@show mdl.x
@show mdl.y
@show mdl.u
@show mdl.s

Modeling.X(::MyDef) = ComponentVector(a = 0.0, b = zeros(2))</code></pre><p>Modeling.X: for a leaf component, it must return an AbstractVector. If this method is not defined, the leaf component will have no continuous state by default. For a node component, you typically don&#39;t need to extend this method; its continuous state vector will be automatically assembled from those of its children, and it will share memory with them. Children</p><p>Modeling Very simple example of composition. Show that</p><p>Question: couldn&#39;t the model&#39;s <code>parameters</code> and <code>submodels</code> also be specified via method extension? Given that the <code>Model</code> constructor extracts the fields and processes it depending on what they are, why not simply leave the <code>ModelDefinition</code> as an empty struct and define the following functions: <code>Modeling.Constants(::MyDef)</code> <code>Modeling.Submodels(::MyDef)</code></p><p>The answer is that this would prevent the user from creating different instances of a <code>Model</code>, each one with its own constant parameter values or submodels. The high-level explanation comes from asking the question: what characterizes a specific instance of a <code>Model</code>? Its specific constant parameters, and the specific instances of the submodels it holds. Therefore, these must be left to be specified when creating each instance, so they should not be universally set by method extensions.</p><p>In contrast, for example, we know that for a leaf model, its x will always have the same structure. And for a node model, it will be assembled from its children&#39;s x.</p><hr/><h4 id="Hierarchical-Composition-with-ComponentArrays"><a class="docs-heading-anchor" href="#Hierarchical-Composition-with-ComponentArrays">Hierarchical Composition with <code>ComponentArrays</code></a><a id="Hierarchical-Composition-with-ComponentArrays-1"></a><a class="docs-heading-anchor-permalink" href="#Hierarchical-Composition-with-ComponentArrays" title="Permalink"></a></h4><p>The framework&#39;s power comes from its hierarchical nature. The state vector <code>x</code> of a parent <code>Model</code> is a <code>ComponentVector</code> that is recursively built from the state vectors of its children. This provides two key benefits:</p><ol><li><strong>Human-Readable State:</strong> You can access the state of any component with an intuitive dot  notation (e.g., <code>aircraft.vehicle.systems.pwp.engine.x.ω</code>).</li><li><strong>Performance:</strong> The entire state vector remains a single, contiguous block of memory, which is  essential for the performance of the ODE solver.</li></ol><p>[<strong>NEW</strong>] The <code>Model</code>&#39;s output <code>y</code> is also constructed hierarchically. After a component&#39;s update function is called, its <code>y</code> field is updated. Parent models can then access the outputs of their children via <code>child.y</code> to compute their own <code>y</code>. This bottom-up assembly ensures that all information is current. While this means some output data may be present at multiple levels of the hierarchy, the performance impact is negligible because the output <code>struct</code>s are required to be <code>isbits</code> types (immutable and stack-allocated), making these operations extremely fast. It is ultimately the developer&#39;s choice which child outputs to propagate upwards. However, since the <code>Simulation</code> log only records the root <code>Model</code>&#39;s output, any information that is not included in it will not be saved.</p><h4 id="The-Update-Interface:-Causal,-Programmatic-Dynamics"><a class="docs-heading-anchor" href="#The-Update-Interface:-Causal,-Programmatic-Dynamics">The Update Interface: Causal, Programmatic Dynamics</a><a id="The-Update-Interface:-Causal,-Programmatic-Dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#The-Update-Interface:-Causal,-Programmatic-Dynamics" title="Permalink"></a></h4><ul><li><code>f_ode!(model, ...)</code>: Defines the continuous dynamics (<code>ẋ = f(x, u, t)</code>). This is called by the   ODE solver at each integration step and is the performance-critical &quot;hot loop&quot; of the   simulation.</li><li><code>f_step!(model, ...)</code>: Defines logic that executes <em>after</em> each successful integration step. It   is typically used for discrete state transitions, such as a &quot;weight-on-wheels&quot; flag changing   from <code>false</code> to <code>true</code>.</li><li><code>f_periodic!(model, ...)</code>: Defines logic that executes at fixed, discrete time intervals (<code>Δt</code>).   This is the ideal place for implementing digital controllers, guidance laws, and other   discrete-time algorithms.</li></ul><h3 id="The-Update-Cycle:-The-API-Contract"><a class="docs-heading-anchor" href="#The-Update-Cycle:-The-API-Contract">The Update Cycle: The API Contract</a><a id="The-Update-Cycle:-The-API-Contract-1"></a><a class="docs-heading-anchor-permalink" href="#The-Update-Cycle:-The-API-Contract" title="Permalink"></a></h3><p>Every component you create must adhere to a simple but strict API contract by extending a set of standard functions. The simulation engine guarantees when and how these functions are called.</p><ul><li><p><code>f_ode!(model, ...)</code> This is the heart of the continuous simulation. It is called multiple times   per integration step by the ODE solver. Its single purpose is to compute the state derivative   <code>model.ẋ</code> based on the current state <code>model.x</code>, inputs <code>model.u</code>, and time <code>model.t</code>. <strong>This is   the performance-critical hot loop of your simulation.</strong></p></li><li><p><code>f_periodic!(model, ...)</code> This function is called by the simulation at fixed time intervals   (<code>Δt</code>). It is used to model discrete-time dynamics. This is the correct place for:</p><ul><li>Digital control logic (PIDs, LQRs).</li><li>State machines (e.g., <code>engine_state</code> transitions).</li><li>Updating gain schedules.</li></ul></li><li><p><code>f_step!(model, ...)</code> This function is called once at the end of every successful ODE   integration step. It is ideal for tasks that must happen after a state update but are not part   of the continuous dynamics, such as re-normalizing a quaternion to prevent numerical drift.</p></li><li><p><code>init!(model, ...)</code> This is called to set the initial conditions for the model&#39;s states (<code>x</code> and   <code>s</code>) and inputs (<code>u</code>) before a simulation run begins.</p></li></ul><p>The <code>@sm_updates</code> macro can be used on a parent <code>ModelDefinition</code> to automatically generate recursive update methods that call the corresponding methods on all its submodels.</p><hr/><p>[<strong>EXPANDED</strong>] These three core methods can be defined with any number of arguments beyond the <code>Model</code> itself, allowing parent models to pass down necessary data (like atmospheric conditions or kinematic data) to their children. However, a <strong>root <code>Model</code></strong>—one that is passed directly to the <code>Simulation</code> constructor—must define single-argument versions of these methods. If a root <code>Model</code> needs to interact with the outside world, it should use the package&#39;s I/O capabilities (for joysticks, network, etc.) or a user-defined callback, not method arguments.</p><p>[<strong>NEW</strong>] When extending the periodic update function, developers must define their method for the <code>NoScheduling</code> dispatch type: <code>f_periodic!(::NoScheduling, mdl::Model, args...)</code>. The framework uses this dispatch internally to distinguish between user-defined logic and the scheduling mechanism that determines <em>if</em> the logic should run on a given step. Calling <code>f_periodic!(mdl, args...)</code> without the <code>NoScheduling</code> dispatcher will correctly invoke the scheduling logic.</p><p>[<strong>EXPANDED</strong>] To enable efficient simulation of systems with components operating at different frequencies (e.g., a high-frequency inner-loop controller and a low-frequency guidance system), the framework provides the <code>Subsampled</code> wrapper. By wrapping a <code>ModelDefinition</code> in <code>Subsampled(definition, K)</code>, you specify that its <code>f_periodic!</code> function should be called every <code>K</code>-th period of its <strong>parent&#39;s</strong> periodic execution. The absolute sampling period of any component is therefore the product of the root <code>Simulation</code>&#39;s <code>Δt</code> and the <code>K</code> multipliers of all <code>Subsampled</code> models in its branch of the hierarchy.</p><h3 id="Dispatching-on-Parametric-ModelDefinitions"><a class="docs-heading-anchor" href="#Dispatching-on-Parametric-ModelDefinitions">Dispatching on Parametric <code>ModelDefinition</code>s</a><a id="Dispatching-on-Parametric-ModelDefinitions-1"></a><a class="docs-heading-anchor-permalink" href="#Dispatching-on-Parametric-ModelDefinitions" title="Permalink"></a></h3><p>A potential source of perplexity and frustration occurs when working with parametric ModelDefinitions. If MyModelDef is parametric, Julia will NOT dispatch on a method f(::Model{MyModelDef}). One needs to define f(::Model{&lt;:MyModelDef}) instead. This can be a source of perplexity and frustration to anyone not too familiar with the Julia type system.</p><h3 id="Parent-Child-Linkage-Options-for-U-and-S"><a class="docs-heading-anchor" href="#Parent-Child-Linkage-Options-for-U-and-S">Parent-Child Linkage Options for U and S</a><a id="Parent-Child-Linkage-Options-for-U-and-S-1"></a><a class="docs-heading-anchor-permalink" href="#Parent-Child-Linkage-Options-for-U-and-S" title="Permalink"></a></h3><pre><code class="nohighlight hljs">using Flight
import .Modeling: U

struct Leaf &lt;: ModelDefinition end

Modeling.U(::Leaf) = [0.0]

@kwdef struct Node1 &lt;: ModelDefinition
a::Leaf = Leaf()
b::Leaf = Leaf()
end

@kwdef struct Node2 &lt;: ModelDefinition
a::Leaf = Leaf()
b::Leaf = Leaf()
end

U(node::Node1) = (a = U(node.a), b = U(node.b))
U(node::Node2) = ComponentVector(a = U(node.a), b = U(node.b))

mdl1 = Node1() |&gt; Model
mdl2 = Node2() |&gt; Model

@assert mdl1.u isa NamedTuple
@assert mdl1.u.a === mdl1.a.u

@assert mdl2.u isa ComponentVector
@assert mdl2.u.a === mdl2.a.u #Component mdl.u returns a view into its a block</code></pre><p>What&#39;s happening is that upon construction, <code>mdl.a</code> input <code>u</code> is assigned a view of <code>mdl.u</code>&#39;s <code>a</code> block.</p><h3 id="The-Performance-Contract:-Your-Responsibility"><a class="docs-heading-anchor" href="#The-Performance-Contract:-Your-Responsibility">The Performance Contract: Your Responsibility</a><a id="The-Performance-Contract:-Your-Responsibility-1"></a><a class="docs-heading-anchor-permalink" href="#The-Performance-Contract:-Your-Responsibility" title="Permalink"></a></h3><p><em>If you care about performance!</em></p><p>The exceptional performance of <code>Flight.jl</code> is not magic; it comes from a disciplined implementation approach that every developer must follow for their own components. By extending the framework, you agree to this &quot;performance contract&quot;:</p><p>!!! warning &quot;The Performance Contract&quot; To ensure the high-performance, real-time capabilities of the     simulation, your component implementations must adhere to the following rules.</p><ol><li><strong>Be Type-Stable:</strong> All functions in the update cycle, especially <code>f_ode!</code>, must be type-stable.  The types of variables should not change within the function. Use tools like <code>@code_warntype</code> to  verify.</li><li><strong><code>f_ode!</code> Must Not Allocate:</strong> The continuous dynamics function is the hot loop. It <strong>must not  allocate any memory on the heap</strong>.<ul><li>Use <code>StaticArrays</code> (<code>SVector</code>, <code>SMatrix</code>) for all small, fixed-size vector and matrix   operations.</li><li>Do not create standard <code>Vector</code>s, <code>Matrix</code>es, or other heap-allocated objects inside   <code>f_ode!</code>.</li><li>If you need a temporary buffer, pre-allocate it in your <code>ModelDefinition</code> and store it in   <code>model.parameters</code>.</li></ul></li><li><strong>Use the Right Data Structures:</strong><ul><li>Define your outputs (<code>Y</code>) as immutable (<code>isbits</code>) <code>struct</code>s. This avoids allocations when   returning outputs.</li><li>Use <code>ComponentArrays</code> for your state vector (<code>X</code>) to combine performance with readability.</li></ul></li><li><strong>Test Your Performance:</strong> Use the <code>@ballocated</code> macro from <code>BenchmarkTools.jl</code> in your unit  tests to verify that your <code>f_ode!</code> implementation is allocation-free. The <code>Flight.jl</code> source  code provides numerous examples of this.</li></ol><p>Adhering to this contract ensures that your custom components integrate seamlessly into the framework without degrading the performance of the entire simulation.</p><h3 id="Detailed-explanation-for-Model-state-vector-assembly"><a class="docs-heading-anchor" href="#Detailed-explanation-for-Model-state-vector-assembly">Detailed explanation for Model state vector assembly</a><a id="Detailed-explanation-for-Model-state-vector-assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-explanation-for-Model-state-vector-assembly" title="Permalink"></a></h3><p>Excellent question. This is arguably the most elegant and crucial part of the entire framework, and it&#39;s powered by the magic of <code>ComponentArrays.jl</code>. Let&#39;s walk through the process step-by-step.</p><p>The core idea is a <strong>two-pass process</strong>:</p><ol><li><strong>First Pass (Assembly):</strong> Recursively walk the <code>ModelDefinition</code> hierarchy from the bottom up to determine the <em>shape</em> and <em>size</em> of the complete state vector for the root model. This creates a single, contiguous <code>ComponentVector</code>.</li><li><strong>Second Pass (Assignment):</strong> Recursively walk the hierarchy from the top down to build the <code>Model</code> instances. Each <code>Model</code> instance is given a <em>view</em> (or more accurately, a property accessor that behaves like a view) into the relevant slice of the single <code>ComponentVector</code> created in the first pass.</li></ol><p>Let&#39;s illustrate with a simple example hierarchy:</p><pre><code class="language-julia hljs"># 1. Define the blueprints (ModelDefinitions)

# The simplest component, a &quot;leaf&quot; in our hierarchy
struct Leaf &lt;: ModelDefinition end
# A leaf&#39;s state is a simple Vector. This is the base case for our recursion.
Modeling.X(::Leaf) = [0.0]

# A composite component, a &quot;node&quot;
struct Node &lt;: ModelDefinition
    leaf_C::Leaf = Leaf()
    leaf_D::Leaf = Leaf()
end

# The top-level component, the &quot;root&quot;
struct Root &lt;: ModelDefinition
    leaf_A::Leaf = Leaf()
    node_B::Node = Node()
end</code></pre><p>Our hierarchy looks like this:</p><pre><code class="nohighlight hljs">Root
├── leaf_A (Leaf)
└── node_B (Node)
    ├── leaf_C (Leaf)
    └── leaf_D (Leaf)</code></pre><p>Now, let&#39;s trace what happens when we call <code>Model(Root())</code>.</p><hr/><h3 id="Pass-1:-Assembling-the-State-Vector-(Bottom-Up)"><a class="docs-heading-anchor" href="#Pass-1:-Assembling-the-State-Vector-(Bottom-Up)">Pass 1: Assembling the State Vector (Bottom-Up)</a><a id="Pass-1:-Assembling-the-State-Vector-(Bottom-Up)-1"></a><a class="docs-heading-anchor-permalink" href="#Pass-1:-Assembling-the-State-Vector-(Bottom-Up)" title="Permalink"></a></h3><p>The entry point is <code>Model(Root())</code>. The very first thing this constructor needs to know is the complete state vector for a <code>Root</code> model. It finds this by calling <code>X(Root())</code>.</p><p><strong>Step 1.1: <code>X(Root())</code> is called.</strong></p><p>The default implementation of <code>X</code> for a composite <code>ModelDefinition</code> does the following:</p><ul><li>It finds all fields that are themselves <code>ModelDefinition</code>s (here, <code>:leaf_A</code> and <code>:node_B</code>).</li><li>It recursively calls <code>X()</code> on each of them.</li><li>It assembles the results into a <code>ComponentVector</code>.</li></ul><p>So, <code>X(Root())</code> triggers two calls:</p><ol><li><code>X(mdl.leaf_A)</code> which is <code>X(Leaf())</code></li><li><code>X(mdl.node_B)</code> which is <code>X(Node())</code></li></ol><p><strong>Step 1.2: Base Case - <code>X(Leaf())</code></strong></p><p>This is the <strong>base case</strong> of our recursion. We have explicitly defined <code>Modeling.X(::Leaf) = [0.0]</code>. So, this call simply returns <code>[0.0]</code>. The recursion for this branch stops.</p><p><strong>Step 1.3: Recursive Call - <code>X(Node())</code></strong></p><p>Just like <code>X(Root())</code>, the <code>X(Node())</code> method finds its own children <code>ModelDefinition</code>s (<code>:leaf_C</code> and <code>:leaf_D</code>) and calls <code>X()</code> on them.</p><ul><li><code>X(mdl.leaf_C)</code> calls <code>X(Leaf())</code> and gets <code>[0.0]</code>.</li><li><code>X(mdl.leaf_D)</code> calls <code>X(Leaf())</code> and gets <code>[0.0]</code>.</li></ul><p>Now, <code>X(Node())</code> assembles these results into a <code>ComponentVector</code>, using the field names as keys: <code>ComponentVector(leaf_C = [0.0], leaf_D = [0.0])</code>. This object has a named structure but stores its data in a flat, contiguous vector: <code>[0.0, 0.0]</code>.</p><p><strong>Step 1.4: Final Assembly in <code>X(Root())</code></strong></p><p>The execution now returns to the top-level call, <code>X(Root())</code>. It has received the results from its children:</p><ul><li>From <code>leaf_A</code>: <code>[0.0]</code></li><li>From <code>node_B</code>: <code>ComponentVector(leaf_C = [0.0], leaf_D = [0.0])</code></li></ul><p>It assembles these into the final, complete <code>ComponentVector</code> for the entire hierarchy: <code>x_root = ComponentVector(leaf_A = [0.0], node_B = (leaf_C = [0.0], leaf_D = [0.0]))</code></p><p><strong>Crucially, <code>x_root</code> is a single object whose data is stored in a single, contiguous block of memory:</strong> <code>[0.0, 0.0, 0.0]</code>. The nested naming (<code>x_root.node_B.leaf_C</code>) is just a convenient and efficient way to access slices of this underlying flat vector. This answers your &quot;contiguous in memory&quot; question. The ODE solver will only ever see this single, flat <code>Vector{Float64}</code>.</p><hr/><h3 id="Pass-2:-Assigning-Views-to-Model-Instances-(Top-Down)"><a class="docs-heading-anchor" href="#Pass-2:-Assigning-Views-to-Model-Instances-(Top-Down)">Pass 2: Assigning Views to <code>Model</code> Instances (Top-Down)</a><a id="Pass-2:-Assigning-Views-to-Model-Instances-(Top-Down)-1"></a><a class="docs-heading-anchor-permalink" href="#Pass-2:-Assigning-Views-to-Model-Instances-(Top-Down)" title="Permalink"></a></h3><p>Now that the master state vector <code>x_root</code> is created, the <code>Model</code> constructor can create the instances.</p><p><strong>Step 2.1: The Root <code>Model</code> is Created</strong></p><p>A <code>Model{Root}</code> instance is created. Its <code>x</code> field is assigned the complete <code>x_root</code> <code>ComponentVector</code> we just built.</p><p><strong>Step 2.2: The Children <code>Model</code>s are Created</strong></p><p>The <code>Model(Root())</code> constructor now iterates through its children <code>ModelDefinition</code>s (<code>leaf_A</code> and <code>node_B</code>) to create their <code>Model</code> instances.</p><ul><li><p><strong>For <code>leaf_A</code>:</strong> It creates a <code>Model{Leaf}</code>. For the <code>x</code> field of this child model, it does not create a new vector. Instead, it passes <code>x_root.leaf_A</code>. This is the key step. <code>x_root.leaf_A</code> is not a copy; it&#39;s a &quot;view&quot; or a &quot;property accessor&quot; into the first element of <code>x_root</code>&#39;s underlying data. The <code>leaf_A</code> model now holds a direct reference to its slice of the master state vector.</p></li><li><p><strong>For <code>node_B</code>:</strong> It creates a <code>Model{Node}</code>. For its <code>x</code> field, it passes <code>x_root.node_B</code>. This is a view into the last two elements of <code>x_root</code>&#39;s data.</p></li></ul><p><strong>Step 2.3: The Grandchildren <code>Model</code>s are Created</strong></p><p>The process continues recursively. When the <code>Model{Node}</code> for <code>node_B</code> is being constructed, it in turn looks at its own children:</p><ul><li><p><strong>For <code>leaf_C</code>:</strong> It creates a <code>Model{Leaf}</code>. It receives the view <code>x_root.node_B</code> from its parent. It then passes <code>(x_root.node_B).leaf_C</code> to its child <code>leaf_C</code>. This is a view into the second element of the master <code>x_root</code> vector.</p></li><li><p><strong>For <code>leaf_D</code>:</strong> It does the same, passing <code>(x_root.node_B).leaf_D</code> to its child <code>leaf_D</code>, which is a view into the third element of <code>x_root</code>.</p></li></ul><h3 id="The-Final-Result"><a class="docs-heading-anchor" href="#The-Final-Result">The Final Result</a><a id="The-Final-Result-1"></a><a class="docs-heading-anchor-permalink" href="#The-Final-Result" title="Permalink"></a></h3><p>After the constructor finishes, we have a tree of <code>Model</code> objects.</p><ul><li>The <code>root_model</code> holds the <strong>one and only</strong> complete, contiguous state vector: <code>x_root</code>.</li><li>Every child, grandchild, and so on, holds an <code>x</code> field that is simply a <strong>lightweight view</strong> pointing to its designated section within that single master vector.</li></ul><p>When the ODE solver updates the state, it modifies the elements of <code>x_root</code>. Because all submodels hold views into this same block of memory, they all instantly see the updated state without any copying or communication required.</p><p>Conversely, when a leaf model like <code>leaf_C</code> computes its derivative in <code>f_ode!</code> and writes to its <code>ẋ</code> field, it is actually modifying the specific slice of the root model&#39;s <code>ẋ</code> vector that corresponds to its state.</p><p>This design is brilliant because it combines:</p><ol><li><strong>Readability:</strong> You can access any state from the top down with a clean, hierarchical syntax (<code>root_model.node_B.leaf_C.x</code>).</li><li><strong>Performance:</strong> There is only one block of memory for the entire state, making it extremely friendly to the ODE solver and the CPU cache.</li><li><strong>Composability:</strong> The logic for defining the shape of the state (<code>X(::MyDef)</code>) is local to each component, but the framework automatically assembles it into a global, performant structure.</li></ol></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 26 September 2025 17:47">Friday 26 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
