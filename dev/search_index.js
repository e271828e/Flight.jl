var documenterSearchIndex = {"docs":
[{"location":"tutorials/tutorial02/tutorial02/#Headless-Simulation","page":"Headless Simulation","title":"Headless Simulation","text":"","category":"section"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"In this tutorial, we revisit our interactive simulation setup. This time, we will learn how to run the Simulation programmatically and extract results for inspection and plotting.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/#Peeking-Into-the-Model","page":"Headless Simulation","title":"Peeking Into the Model","text":"","category":"section"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Let's start from a new SimpleWorld instance. Here, keeping consistency with X-Plane's visuals is no longer a concern, so we can stick to the default constructors:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"using Flight\nworld = SimpleWorld(Cessna172Xv1(), SimpleAtmosphere(), HorizontalTerrain()) #zero-MSL terrain","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Inspecting its type hierarchy reveals that SimpleWorld is a concrete subtype of the abstract type ModelDefinition:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"using InteractiveUtils\nsupertypes(SimpleWorld)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"An instance of a ModelDefinition subtype can be thought of as a blueprint specifying how a particular Model should be built. To instantiate this Model, we pass the ModelDefinition object to the Model constructor:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"mdl = Model(world)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Let's take a look at this Model's properties:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"propertynames(mdl)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Here is a brief description of each one:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"x (continuous state): A vector containing Model states that evolve continuously over time. It is updated by the Simulation's ODE integrator.\nẋ (continuous state derivative): A vector containing the time derivative of x.\ns (discrete state): A mutable type holding Model states that change only at specific moments in time.\nu (input): A mutable type holding the Model's input variables. These are assigned either by a parent Model or an external source.\ny (output): An immutable type holding all the relevant results from the Model's computations. These may be used by a parent Model or saved in the Simulation's log.\nt (time): A reference to the current simulation time.\nΔt (sampling period): The time interval for the Model's periodic updates.\nconstants: A NamedTuple containing Model parameters that do not change during simulation.\nsubmodels: A NamedTuple of child Models that represent components of the parent Model.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"The remaining properties are entries from constants and submodels. These may be accessed directly via dot notation:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"@show keys(mdl.constants)\n@show keys(mdl.submodels)\n@show mdl.atmosphere\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"A submodel can have submodels of its own:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"@show keys(mdl.atmosphere.submodels)\n@show mdl.atmosphere.sl\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Thus, a complex Model can be made up of multiple, hierarchically arranged components, each one of them itself a Model. To visualize a Model's hierarchy, you can use the print_tree function:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"using AbstractTrees\nprint_tree(mdl; maxdepth = 10)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"You can also inspect a specific property across a Model's hierarchy. For example, to view the discrete state of mdl.aircraft.avionics.ctl and every node underneath:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"print_tree(mdl.aircraft.avionics.ctl, :s; maxdepth = 10);","category":"page"},{"location":"tutorials/tutorial02/tutorial02/#Simulating-an-Elevator-Doublet","page":"Headless Simulation","title":"Simulating an Elevator Doublet","text":"","category":"section"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Our plan for this section is as follows:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Create a Simulation.\nInitialize the aircraft in a trimmed state.\nApply an elevator doublet by setting the appropriate inputs and stepping the Simulation manually.\nLet the Simulation run to completion.\nExtract and plot some logged variables to observe the aircraft's response.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Let's begin by creating a Simulation from our Model:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"sim = Simulation(mdl; dt = 0.02, t_end = 60)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"tip: From a ModelDefinition\nYou can also pass a ModelDefinition object directly to the Simulation constructor. In that case, the Model is instantiated automatically under the hood:Simulation(world; dt = 0.02, t_end = 60)\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"The Model is now stored within the Simulation, and it can be accesed at any time for inspection or manipulation:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"@assert mdl === sim.mdl","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Next, let's define a trim condition and use it to initialize the Simulation:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"init_air = C172.TrimParameters(); #straight and level, default airspeed and altitude\nSim.init!(sim, init_air)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"You may recall how during interactive simulation we used the Aircraft > Avionics > Flight Control GUI panel to control the aircraft. That panel belongs to the mdl.aircraft.avionics.ctl node, which implements the flight control laws for the Cessna172Xv1 aircraft. Let's retrieve its input struct:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"u_ctl = mdl.aircraft.avionics.ctl.u;\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"It is this struct that the control inputs in the Aircraft > Avionics > Flight Control panel mapped to. Here, we will be writing to it directly. To inspect its fields, we can use the shf helper function:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"shf(u_ctl)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Note how the trim function, invoked by the Sim.init! call, has already set the primary control inputs (throttle_axis, elevator_axis, aileron_axis and rudder_axis) to the values required by the trimmed flight condition. Also, the longitudinal and lateral control mode inputs (lon_ctl_mode_req and lat_ctl_mode_req) are set to their direct values. This bypasses all control loops, preserving the aircraft's natural dynamic response, which is what we want in this case.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Let's first advance the Simulation a few seconds without perturbing the trim equilibrium. To do so, we use the Sim.step! method, which essentially wraps the one from DifferentialEquations.jl's integrator interface.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Sim.step!(sim, 5) #advance the simulation 5 seconds","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"To apply the elevator doublet, we can either modify the elevator_axis input or, more conveniently, use elevator_offset instead. Here's how to do it:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"u_ctl.elevator_offset = 0.1 #10 percent positive offset\nSim.step!(sim, 2) #advance 2 seconds\nu_ctl.elevator_offset = -0.1 #10 percent negative offset\nSim.step!(sim, 2) #advance 2 seconds\nu_ctl.elevator_offset = 0.0 #return to trim position\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"After this, we don't need to interact with the Simulation any further, so we can let it run to completion:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Sim.run!(sim)\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Now let's get some results.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"A Simulation's log consists of the timestamped values of its root Model's output. The easiest way to retrieve and handle this data is through the TimeSeries type:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"ts = TimeSeries(sim)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"tip: Controlling logging behavior\nBy default, the Model's outputs are saved at every integration step. You can use the saveat keyword argument to control logging behavior:Simulation(mdl; dt = 0.02, t_end = 60, saveat = 0.1) #every 0.1s\nSimulation(mdl; dt = 0.02, t_end = 60, saveat = [0:0.1:10..., 11:1:60...]) #specific instants\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"A TimeSeries object lets you inspect the properties of its underlying data type, and generate another TimeSeries object for any of these properties. This is particularly convenient when dealing with large, deeply nested types, as Model outputs often are. Let's see a few examples:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"@show propertynames(ts)\n@show propertynames(ts.aircraft)\n@show propertynames(ts.aircraft.vehicle)\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"ts_kin = ts.aircraft.vehicle.kinematics\nts_sys = ts.aircraft.vehicle.systems\nts_ω = ts_kin.ω_wb_b #angular velocity, Wander frame to Body frame (rad/s)\nts_θ = ts_kin.e_nb.θ #pitch angle, NED frame to Body frame (rad)\nts_α = ts_sys.aero.α #angle of attack (rad)\nts_el_cmd = ts_sys.act.elevator.cmd[4 .<= get_time(ts) .< 10] #elevator command\nts_el_pos = ts_sys.act.elevator.pos[4 .<= get_time(ts) .< 10] #elevator position\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Plots.jl recipes are available for many common TimeSeries subtypes, so plotting is usually straightforward:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"import Plots\nusing LaTeXStrings\nPlots.default(:size, (900, 600))\nPlots.default(:left_margin, 16Plots.px)\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"#TimeSeries{<:Ranged} recipe\nPlots.plot(ts_el_cmd; plot_title=\"Elevator Response\", label = \"Command\")\nPlots.plot!(ts_el_pos; label = \"Position\")","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"#TimeSeries{<:AbstractVector{<:Real}} recipe\nPlots.plot(ts_ω; plot_title=\"Angular Velocity\", ylabel=L\"$\\omega \\ (rad/s)$\")","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"#TimeSeries{Real} recipe\nPlots.plot(ts_α; plot_title=\"AoA vs Pitch Angle\", ylabel=L\"$\\alpha, \\ \\theta \\ (rad)$\", label=\"AoA\")\nPlots.plot!(ts_θ; label = \"Pitch Angle\")","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"&nbsp;","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"In addition to individual TimeSeries recipes, you can use the make_plots function to generate a set of typically useful plots from a specific TimeSeries subtype. Here are some examples:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"plots_kin = make_plots(ts.aircraft.vehicle.kinematics)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"plots_kin[:Ob_t3d]","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"plots_dyn = make_plots(ts.aircraft.vehicle.dynamics)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"plots_dyn[:f_c_c]","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"plots_air = make_plots(ts.aircraft.vehicle.airflow)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"plots_air[:airspeed_M_q]","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"&nbsp;","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"To save all the plots in one of these sets you can do:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"save_plots(plots_kin, normpath(\"tmp/plots/kin\"))\nrm(normpath(\"tmp/plots/kin\"), recursive = true) #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Or, directly from the TimeSeries object:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"save_plots(ts.aircraft.vehicle.kinematics, normpath(\"tmp/plots/kin\"))\nrm(normpath(\"tmp/plots/kin\"), recursive = true) #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/#Automating-Model-Control-With-User-Callbacks","page":"Headless Simulation","title":"Automating Model Control With User Callbacks","text":"","category":"section"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Stepping through the Simulation and assigning inputs at each stop is not always the best approach for controlling a Model during headless Simulation runs. In many cases, it is cleaner and more convenient to define and encapsulate the control logic in advance, and then let the Simulation run uninterrupted from start to finish.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"This is where user callbacks come in. These are custom functions with the signature user_callback!(::Model) called by the Simulation after every integration step. The main purpose of user callbacks is to automate Model input management.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"warning: Modifying Model State\nUser callbacks should only be used to assign Model inputs; do not modify a Model's continuous or discrete states within a user callback unless you really know what you're doing.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Let's define a user callback implementing our elevator doublet logic:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"user_callback! = function(mdl::Model)\n    t = mdl.t[] #mdl.t is a RefValue, we need to dereference it\n    u_ctl = mdl.aircraft.avionics.ctl.u\n    if 5 <= t < 7\n        u_ctl.elevator_offset = 0.1\n    elseif 7 <= t < 9\n        u_ctl.elevator_offset = -0.1\n    else\n        u_ctl.elevator_offset = 0\n    end\nend","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"All we need to do now is create a new Simulation with this function definition as a keyword argument, initialize it as before, and run it:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"sim = Simulation(mdl; dt = 0.02, t_end = 60, user_callback!)\nSim.init!(sim, init_air)\nSim.run!(sim)\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"As expected, we get exactly the same result:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"ts = TimeSeries(sim)\nts_el = ts.aircraft.vehicle.systems.act.elevator[4 .<= get_time(ts) .< 10]\nPlots.plot(ts_el.cmd; plot_title=\"Elevator Response\", label = \"Command\")\nPlots.plot!(ts_el.pos; label = \"Position\")","category":"page"},{"location":"tutorials/tutorial02/tutorial02/#A-More-Complex-Example","page":"Headless Simulation","title":"A More Complex Example","text":"","category":"section"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Then move on to complex multi-phase flight. Ground init, startup, take-off, spiral climb until h condition","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"world.ac.avionics.ctl.u.lonctlmodereq |> typeof using .C172X.C172XControl: londirect, lon_sas","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"These values come from fields in the ModelDefinition subtype that are not   themselves ModelDefinitions.     These Models are built from those fields in the ModelDefinition subtype that are themselves   ModelDefinitions.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"When the Model constructor is called on a ModelDefinition, those fields that are themselves ModelDefinitions are also turned into Models, and they become children in the parent Model's hierarchy. Therefore, within submodels we will find Models created from the Cessna172Xv1, SimpleAtmosphere and HorizontalTerrain objects we passed to the SimpleWorld constructor.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"mdl.submodels","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"The ModelDefinition subtype is preserved as the Model's first type parameter. It serves both as the Model's primary identifier and as a dispatch mechanism when calling Model update functions.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Maybe use user_callbaack to export additional Model information not available in the Sim log","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"<!– , tsq, _ = getcomponents(tsω); #pitch rate (rad/s) –>","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#FlightLib","page":"API","title":"FlightLib","text":"","category":"section"},{"location":"api/#Dynamics","page":"API","title":"Dynamics","text":"","category":"section"},{"location":"api/#Flight.FlightLib.Dynamics.FrameTransform","page":"API","title":"Flight.FlightLib.Dynamics.FrameTransform","text":"Specify a reference frame c with respect to another b.\n\nc is defined by:\n\nr_bc^b: Position vector from b's origin O_b to c's origin O_c, projected on b's axes Ɛ_b\nq^b_c: Rotation quaternion from b's axes Ɛ_b to c's axes Ɛ_c\n\nFrameTransform objects are callable; the syntax t_bc(x_c) is equivalent to translate(t_bc, x_c).\n\n\n\n\n\n","category":"type"},{"location":"api/#Flight.FlightLib.Dynamics.translate-Tuple{FrameTransform, AbstractVector{<:Real}}","page":"API","title":"Flight.FlightLib.Dynamics.translate","text":"translate(t_bc::FrameTransform, r_cP_c::AbstractVector{<:Real})\n\nTranslate a 3D position vector from one reference frame to another.\n\nGiven the FrameTransform t_bc from frame b to frame c and the position vector of some point P in c (r_cP^c), return the position vector of P in b (r_bP^b).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.adjoint-Tuple{FrameTransform}","page":"API","title":"Base.adjoint","text":"Base.:adjoint(t_bc::FrameTransform)\n\nGiven t_bc, return its reciprocal t_cb.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:∘-Tuple{FrameTransform, FrameTransform}","page":"API","title":"Base.:∘","text":"Base.:∘(t_bc::FrameTransform, t_cd::FrameTransform)\n\nConcatenate FrameTransforms t_bc and t_cd and return the resulting t_bd.\n\n\n\n\n\n","category":"method"},{"location":"api/#Flight.FlightLib.Dynamics.Wrench","page":"API","title":"Flight.FlightLib.Dynamics.Wrench","text":"Force and torque combination defined in a specific reference frame.\n\nA Wrench is defined in frame c when it is applied at c's origin O_c and projected on its axes Ɛ_c\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"tutorials/tutorial01/tutorial01/#Interactive-Simulation","page":"Interactive Simulation","title":"Interactive Simulation","text":"","category":"section"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"This tutorial shows how to set up and run an interactive aircraft simulation. You will be able to control it through the built-in GUI and, optionally, use the free X-Plane 12 demo for 3D visualization.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/#Setting-Up-X-Plane-12","page":"Interactive Simulation","title":"Setting Up X-Plane 12","text":"","category":"section"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Download, install and run the X-Plane 12 demo. If you happen to have the full version, you can use it instead. Since we will be using X-Plane simply as an external visualization tool, we only need to set up a few things; for further help, check out the X-Plane 12 manual.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"note: No X-Plane?\nIf you can't run X-Plane 12 (which might happen for instance if you have an Intel integrated graphics chip), you can skip this section. Your visuals will be limited to the built-in GUI, but everything else should still work.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"From the main menu, click on New Flight. Select the Cessna Skyhawk as your aircraft and Salzburg (LOWS) as your initial location. Start the flight.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: X-Plane 12 New Flight Screen)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"To switch to an external camera, press Shift+4. Right click and drag to rotate the view and use the mouse wheel to zoom in and out. To return to the cockpit camera, press Shift+0.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: X-Plane 12 Settings Icon)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Move the mouse to the top of the screen to bring up the menu bar. Click on the Settings icon and go the Network tab. Make sure Accept incoming connections is enabled. Then, under the UDP Ports section, check the Port we receive on (legacy) value. The default is 49000, but you can use a different one if you need to. Finally, if you are running X-Plane on a different machine than your Julia session, note its IP address.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: X-Plane 12 Network Settings)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Now go to the Graphics tab. Unless you have a multi-monitor setup, you will probably want to run X-Plane in windowed mode. This will allow you to keep it on screen along with the Flight.jl built-in GUI. To enable windowed mode, select Windowed Simulator in the Monitor usage drop-down.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: X-Plane 12 Graphics Settings)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"You might also want to experiment with the quality settings until you achieve a comfortable framerate. To display the framerate on screen, go to the Data Output tab, find the Framerate entry in the table and enable the Show in cockpit option.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: X-Plane 12 Data Output)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"This concludes our X-Plane setup, now let's move on to Julia.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/#Setting-Up-the-Flight.jl-Simulation","page":"Interactive Simulation","title":"Setting Up the Flight.jl Simulation","text":"","category":"section"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"warning: On Multithreading\nTo work through this example, you will need to start Julia with multiple threads enabled.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Let's begin by initializing the package:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"using Flight","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Next, we need to define a 2D location and orthometric elevation for the beginning of Salzburg airport's runway 15, as well as the runway's geographic heading:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"loc_LOWS15 = LatLon(ϕ = deg2rad(47.80433), λ = deg2rad(12.997))\nh_LOWS15 = HOrth(427.2)\nψ_LOWS15 = deg2rad(157)\nnothing # hide","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"note: A Caveat On X-Plane Visuals\nThe above values will result in X-Plane displaying the aircraft properly positioned and aligned on the runway centerline at the beginning of the simulation. However, this is just for aesthetics, since our simulation's physics are totally independent from X-Plane's terrain mesh. This disconnect will become apparent as soon as the aircraft starts rolling down the runway.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Our simulated world will consist of an aircraft, an atmospheric model and a terrain model:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"aircraft = Cessna172Xv1()\natmosphere = SimpleAtmosphere()\nterrain = HorizontalTerrain(h_LOWS15)\nworld = SimpleWorld(aircraft, atmosphere, terrain)\nnothing # hide","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"The Cessna172Xv1 aircraft is a hypothetical customization of a Cessna 172S. It replaces the reversible actuation system on the base model with a digital fly-by-wire flight control system, which we will leverage in this example. Note that this aircraft does not aim to replicate the internals or interface of any specific real-world autopilot. Its purpose is simply to illustrate how the Flight.jl framework may be used to design, implement and test complex control architectures. SimpleAtmosphere provides a basic, ISA-based atmospheric model with customizable sea-level conditions and wind velocity. HorizontalTerrain represents a terrain model with constant orthometric elevation, which we have set to our previous value for the beginning of runway 15.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"We can now create our simulation:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"sim = Simulation(world; dt = 0.01) #specifies a suitable integration step size\nnothing # hide","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Under the hood, this call turns our SimpleWorld instance into a Model object, which is what the Simulation will actually interact with. The Model type is central to the Flight.jl framework, and we will look into it further in future examples.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Next, we instantiate an X-Plane 12 control interface and attach it to the simulation. This will allow the simulation to disable X-Plane's physics engine and periodically send our aircraft's state for X-Plane to display:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"xp = XPlane12Control()\nSim.attach!(sim, xp)\nnothing # hide","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"note: X-Plane UDP Settings\nThe default XPlane12Control constructor assumes X-Plane 12 is running on your local machine and listening on port 49000. If this is not the case, you will need to provide the appropriate IP address and/or port (discussed in the X-Plane setup section) as keyword arguments. For example:using Flight # hide\nusing Sockets #bring IPv4 into scope\nxp = XPlane12Control(address = IPv4(\"192.168.1.2\"), port = 49001)\nnothing # hide","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Flight.jl provides basic joystick support via SDL2_jll. Currently, Thrustmaster's T.16000M is the only implemented model. Adding support for other joysticks should be relatively straightforward, but we will not get into it here. If you happen to have a T.16000M available, you can plug it in now and do the following:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"for joystick in update_connected_joysticks()\n    isa(joystick, Joysticks.T16000M) && Sim.attach!(sim, joystick)\nend","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Otherwise, don't worry; in this example, we will let the SAS and autopilot modes handle most of the flying for us. This will make it relatively easy to control the aircraft through the GUI.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"The last step is to define a suitable initial condition. For on-ground initialization, we can do that by specifying the aircraft's frame kinematic state:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"init_gnd = KinInit(;\n    location = loc_LOWS15, #2D location\n    h = h_LOWS15 + C172.Δh_to_gnd, #altitude, as an offset with respect to terrain elevation\n    q_nb = REuler(ψ_LOWS15, 0, 0), #attitude with respect to NED frame, as Euler angles\n    ω_wb_b = zeros(3), #angular velocity with respect to local tangent frame, aircraft frame coordinates\n    v_eb_n = zeros(3), #Earth-relative velocity, NED frame coordinates\n    ) |> C172.Init\nnothing # hide","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Then, we assign it as:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Sim.init!(sim, init_gnd)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/#Running-the-Simulation","page":"Interactive Simulation","title":"Running the Simulation","text":"","category":"section"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Now we can finally start the simulation:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Sim.run_interactive!(sim)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"After a few seconds, the simulation will launch, and a new OS window containing the built-in GUI will open:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: Default GUI)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"The Simulation Control panel lets you pause or resume the simulation, and set its pace relative to wall clock time. To abort the simulation, simply close the GUI window.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"The other panel is specific to our simulated Model. A complex Model like ours comprises a hierarchy of components. Each component is itself a Model, and it typically defines its own GUI panel, which can be accessed from that of its parent. Feel free to explore the GUI to get a picture of the underlying component hierarchy and discover different ways of interacting with the simulation.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"tip: GUI State\nGUI panels can be moved, resized, tiled, docked or grouped as tabs. Try to find the layout that works best for you. GUI state is saved in a file named imgui.ini, which is automatically created in the project's root folder.  Deleting this file will restore the GUI to its default state.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Let's get back to X-Plane for a moment. You should now see the aircraft sitting on the runway with the engine stopped. This indicates that the X-Plane interface was set up properly and our simulation has taken control of the visuals.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: X-Plane 12 Simulation Started)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"note: X-Plane 12 Demo Time Limit\nThe X-Plane 12 demo is time-limited to 15 minutes. After that, an on-screen pop-up will appear. To get rid of it, you can restart X-Plane and click on Resume Last Flight. You will then need to abort the simulation, reset it and run it again:Sim.init!(sim, init_gnd)\nSim.run_interactive!(sim)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Now return to the GUI and navigate to Aircraft > Avionics > Flight Control. This panel contains all the flight control inputs and instrumentation for the Cessna172Xv1 model.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"First, locate the Engine Start button under the Engine section. Press and hold it for a couple of seconds to start the engine.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Next, expand the Longitudinal Control Channel and Lateral Control Channel sections. The first one computes throttle and elevator commands. The second one computes aileron and rudder commands. Both are initialized in Direct mode, wherein each actuator command is set directly to the sum of its corresponding Axis and Offset values. With Direct mode active on both channels, you are essentially flying the base Cessna 172S model, except for the additional actuator dynamics.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Try moving the control surfaces using the Axis and Offset inputs, and observe the result on the GUI's numerical displays or an external X-Plane camera. When you are done, reset all values back to zero.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"note: Joystick Override\nIf you have a joystick attached, the Axis sliders will be overridden by the corresponding joystick axes.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"tip: Keyboard Input\nTo assign a precise value to a control slider, use Ctrl+Click (on Windows) or Cmd+click (on Mac) to enable keyboard input.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Under Longitudinal Control, select the Pitch SAS mode. In this mode, direct throttle control is preserved, but elevator inputs are fed to a pitch compensator, which computes the actual elevator actuator commands. The pitch compensator modifies the natural short-period and phugoid modes, providing a smoother, more stable pitch response. When clicked, the button will turn amber, indicating the mode is now on standby; it will engage automatically upon lift off.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Under Lateral Control, select the Roll/Yaw SAS mode. In this mode, both aileron and rudder inputs are fed to a lateral compensator, which simultaneously computes aileron and rudder actuator commands. This improves the aircraft's Dutch roll response and stabilizes its naturally unstable spiral mode.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Currently, the GUI does not have a graphical instrument panel. Instead, the Flight Data section provides readouts for all essential variables. This will be particularly useful if you're running this example without X-Plane.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: Take-Off GUI)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"That is all we really need to set up for take off. We won't bother with flap settings, rotation or even keeping the aircraft centered on the runway (which, as far as our simulation is concerned, doesn't really exist!). When you're ready, just set the Throttle Axis all the way to 1 and let the aircraft accelerate and lift off on its own.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Once airborne, you will see the previously selected SAS modes turn from amber to green. Let the aircraft climb for a while to give yourself some clearance. Then, spend some time flying with the SAS modes enabled. When you feel comfortable with the controls, try switching back and forth between the Direct and Pitch SAS modes, and compare the aircraft's response to elevator input. You can do the same with the Direct and Roll/Yaw SAS modes to compare aileron and rudder responses, but mind the spiral mode instability!","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"tip: Crashing\nIf the landing gear model detects a crash, it will throw an exception and the simulation will abort. No worries, just reset it and have another go:Sim.init!(sim, init_gnd)\nSim.run_interactive!(sim)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Next, try the EAS + Pitch Rate mode. This mode combines an autothrottle loop with a pitch rate loop built on top of the pitch SAS. Activating this mode will disable all Throttle and Elevator inputs and enable the EAS and Pitch Rate commands. The numerical readout to the right of each command slider shows the current value of its target variable. Try changing the EAS command and observe the response. Then, experiment with the Pitch Rate command. While doing so, keep in mind that an arbitrary pitch rate cannot be sustained indefinitely!","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"note: Mode Transitions\nWhen a new autopilot mode is engaged, its command variables are automatically set to their current values to provide a smooth transition. The exception are Pitch Rate and Roll Rate commands, which are always initialized to zero.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"When you are done, enable the EAS + Climb Rate mode. Set the EAS command to 50 m/s and the Climb Rate command to zero. This will hold your altitude throughout the next steps.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"If you have attempted any turns so far, you may have noticed that the Roll/Yaw SAS mode does not provide automatic turn coordination. For this, you can use one of the higher level lateral modes, all of which track sideslip angle commands. Go ahead and enable the Bank Angle + Sideslip mode. Set the Sideslip Angle command to zero. Then, initiate a turn with the Bank Angle command, and notice how the sideslip angle is indeed held during the turn.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Finally, enable the Course Angle + Sideslip mode. Set the Course Angle to 0 and let the aircraft turn to intercept it. Then, open the Atmosphere > Wind panel. Use the East slider to add some crosswind. Notice how the aircraft turns into the wind, settling on the appropriate heading to maintain the commanded course angle, while also tracking the commanded sideslip angle.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: Course Tracking GUI)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"One final hint before wrapping up. If the whole take-off sequence starts getting tedious, you can skip it entirely by using the trim functionality to initialize the aircraft in flight. Here's how to do it:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"init_air = C172.TrimParameters(;\n    Ob = Geographic(loc_LOWS15, h_LOWS15 + 500), #500 m above runway 15\n    EAS = 50.0, #equivalent airspeed (m/s)\n    ψ_nb = ψ_LOWS15, #runway heading (rad)\n    γ_wb_n = 0.0, #wind-relative flight path angle (rad)\n    ψ_wb_dot = 0.0, #turn rate (rad/s)\n    flaps = 0.0, #flaps position (0 to 1)\n    fuel_load = 0.5, #normalized fuel load (0 to 1)\n)\nSim.init!(sim, init_air)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Feel free to explore the remaining control modes and the altitude guidance function on your own. For more information on Cessna172Xv1's flight controller, check out the source code and the design notebooks for the longitudinal and lateral control channels.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Flight\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Configuring Julia for Multithreading\nDuring simulation, Flight.jl uses multithreading to concurrently handle the simulation loop, the built-in GUI and any attached I/O devices. Therefore, if you intend to use its interactive or I/O capabilities, you will need to start Julia with multiple threads enabled. You can find out how to do this in the manual. However, if you are using the Julia extension for VS Code, the easiest way is to add the following entry to your settings.json:\"julia.additionalArgs\": [\n    \"--threads=auto\",\n],This should work well for most CPUs and use cases. If you run into issues, you can set the number of threads manually to cover your specific needs.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Flight.jl offers a powerful and versatile framework for aircraft modeling, analysis and simulation. Its design fully leverages Julia's expressiveness, extensibility and performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is organized in three distinct layers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A lightweight, domain-agnostic engine for modeling and simulation of complex systems with hybrid dynamics (FlightCore).\nA library of high-fidelity, reusable physics and engineering models (FlightLib).\nA collection of specific aircraft implementations (FlightAircraft).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Key features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hierarchical Modeling: Enables building complex systems from simpler, reusable components,   leveraging ComponentArrays.jl for clarity and convenience.\nHigh Performance: Its core simulation loop is built on DifferentialEquations.jl and   designed from the ground up to be allocation-free. This enables extremely fast headless execution and smooth performance on interactive runs.\nInteractive GUI: Offers an extensible GUI based on CImGui.jl for live model   inspection and manipulation.\nExternal Visualization & I/O: Features out-of-the-box integration with X-Plane   12 for high-fidelity 3D visualization,   joystick support via SDL2_jll, and a generic interface layer for custom I/O functionality.\nSolid Physics Foundation: Includes built-in modules for attitude representation, geodesy, kinematics   and rigid body dynamics, providing fast, accurate and ergonomic types and operations.\nPre-Built Aircraft Components: Comes with high-fidelity, efficient and customizable models for   propellers, piston engines and landing gear.\nIntegrated Control Design Workflow: Provides general-purpose trimming and linearization   functions. Seamlessly import linearized models into the ControlSystems.jl ecosystem for   controller synthesis. Then, realize your design in a practical, discrete-time implementation, and   validate it via nonlinear simulation.","category":"page"}]
}
