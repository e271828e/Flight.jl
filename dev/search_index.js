var documenterSearchIndex = {"docs":
[{"location":"tutorials/tutorial02/tutorial02/#Headless-Simulation","page":"Headless Simulation","title":"Headless Simulation","text":"","category":"section"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"In this tutorial, we revisit our interactive simulation setup. This time, we will learn how to run the Simulation programmatically and extract results for inspection and plotting.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/#Peeking-Into-the-Model","page":"Headless Simulation","title":"Peeking Into the Model","text":"","category":"section"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Let's start from a new SimpleWorld instance. Here, keeping consistency with X-Plane's visuals is no longer a concern, so we can stick to the default constructors:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"using Flight\nworld = SimpleWorld(Cessna172Xv1(), SimpleAtmosphere(), HorizontalTerrain()) #zero-MSL terrain","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Inspecting SimpleWorld's type hierarchy reveals that it is a concrete subtype of the abstract type ModelDefinition:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"using InteractiveUtils\nsupertypes(SimpleWorld)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"An instance of a ModelDefinition subtype can be thought of as a blueprint specifying how a particular Model should be built. To instantiate that Model, we pass the ModelDefinition object to the Model constructor:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"mdl = Model(world)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Let's take a look at our Model's properties:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"propertynames(mdl)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"To make sense of what comes next, it is useful to understand what each one of these represents:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"x (continuous state): A vector containing Model states that evolve continuously over time. It is updated by the Simulation's ODE integrator.\nẋ (continuous state derivative): A vector containing the time derivative of x.\ns (discrete state): A mutable type holding Model states that change only at specific moments in time.\nu (input): A mutable type holding the Model's input variables. These are assigned either by a parent Model or an external source.\ny (output): An immutable type holding all the relevant results from the Model's computations. These may be used by a parent Model or saved in the Simulation's log.\nt (time): A reference to the current simulation time.\nΔt (sampling period): The time interval for the Model's periodic updates.\nparameters: A NamedTuple containing values that characterize a specific Model instance.\nsubmodels: A NamedTuple of child Models that represent components of the parent Model.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"The remaining properties are entries from parameters and submodels. These may be accessed directly via dot notation:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"@show keys(mdl.parameters)\n@show keys(mdl.submodels)\n@show mdl.atmosphere\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"A submodel can have submodels of its own:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"@show keys(mdl.atmosphere.submodels)\n@show mdl.atmosphere.sl\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Thus, a complex Model may be made up of multiple, hierarchically arranged components, each one of them itself a Model. To visualize a Model's hierarchy, you can use the print_tree function:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"using AbstractTrees\nprint_tree(mdl; maxdepth = 10)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"You can also inspect a specific property across a Model's hierarchy. For example, to view the input u for mdl.aircraft.vehicle.systems and every node underneath:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"print_tree(mdl.aircraft.vehicle.systems, :u; maxdepth = 10);","category":"page"},{"location":"tutorials/tutorial02/tutorial02/#Simulating-an-Elevator-Doublet","page":"Headless Simulation","title":"Simulating an Elevator Doublet","text":"","category":"section"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Our plan for this section is as follows:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Create a Simulation.\nInitialize the aircraft in a trimmed state.\nApply an elevator doublet by setting the appropriate inputs and stepping the Simulation manually.\nLet the Simulation run to completion.\nExtract and plot some logged variables to observe the aircraft's response.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Let's begin by creating a Simulation from our Model:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"sim = Simulation(mdl; dt = 0.02, t_end = 60)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"tip: From a ModelDefinition\nYou can also pass a ModelDefinition object directly to the Simulation constructor. In that case, the Model is instantiated automatically under the hood:Simulation(world; dt = 0.02, t_end = 60)\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"The Model is now stored within the Simulation, and it can be accesed at any time for inspection or manipulation:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"@assert mdl === sim.mdl","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Next, let's define a default trim condition and use it to initialize the Simulation:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"init_air = C172.TrimParameters()\ninit!(sim, init_air)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"You may recall how during interactive simulation we used the Aircraft > Avionics GUI panel to control the aircraft. That panel belongs to the mdl.aircraft.avionics node, which provides the flight control laws for the Cessna172Xv1 aircraft. This node has two children:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"print_tree(mdl.aircraft.avionics)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"As you might guess, these implement respectively the aircraft's longitudinal and lateral control laws. The control inputs under the Longitudinal Control section of the Avionics GUI panel mapped to mdl.aircraft.avionics.lon's input struct. Here, we will be writing to this struct directly. Let's retrieve it from the model hierarchy:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"u_lon = mdl.aircraft.avionics.lon.u\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"To inspect its fields, we can use the shf helper function:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"shf(u_lon)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Notice how the trim function, invoked within the previous init! call, has already set the primary control inputs (throttle_axis and elevator_axis) to the values required by the trimmed flight condition. Also, the longitudinal control mode input (lon_ctl_mode_req) is set to its direct value. This bypasses all control loops, preserving the aircraft's natural dynamic response, which is what we want in this case.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Let's first advance the Simulation a few seconds without perturbing the trim equilibrium. To do so, we use the step! method, which essentially wraps the one from DifferentialEquations.jl's integrator interface.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"step!(sim, 5) #advance the simulation 5 seconds","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"To apply the elevator doublet, we can either modify the elevator_axis input or, more conveniently, use elevator_offset instead. Here's how to do it:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"u_lon.elevator_offset = 0.1 #10 percent positive offset\nstep!(sim, 2) #advance 2 seconds\nu_lon.elevator_offset = -0.1 #10 percent negative offset\nstep!(sim, 2) #advance 2 seconds\nu_lon.elevator_offset = 0.0 #return to trim position\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"After this, we don't need to interact with the Simulation any further, so we can let it run to completion:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Sim.run!(sim)\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Now let's get some results.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"A Simulation's log consists of the timestamped values of its root Model's output y. The easiest way to retrieve and handle this data is through the TimeSeries type:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"ts = TimeSeries(sim)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"tip: Controlling logging behavior\nBy default, the Model's outputs are saved at every integration step. You can use the saveat keyword argument to control logging behavior:Simulation(mdl; dt = 0.02, t_end = 60, saveat = 0.1) #every 0.1s\nSimulation(mdl; dt = 0.02, t_end = 60, saveat = [0:0.1:10..., 11:1:60...]) #specific instants\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"A TimeSeries object lets you inspect the properties of its underlying data type, and generate another TimeSeries object for any of these properties. This is particularly convenient when dealing with large, deeply nested types, as Model outputs often are. Let's see a few examples:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"@show propertynames(ts)\n@show propertynames(ts.aircraft)\n@show propertynames(ts.aircraft.vehicle)\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"ts_kin = ts.aircraft.vehicle.kinematics\nts_sys = ts.aircraft.vehicle.systems\nts_ω = ts_kin.ω_wb_b #angular velocity, Wander frame to Body frame (rad/s)\nts_θ = ts_kin.e_nb.θ #pitch angle, NED frame to Body frame (rad)\nts_α = ts_sys.aero.α #angle of attack (rad)\nts_el_cmd = ts_sys.act.elevator.cmd[4 .<= get_time(ts) .< 10] #elevator command\nts_el_pos = ts_sys.act.elevator.pos[4 .<= get_time(ts) .< 10] #elevator position\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Plots.jl recipes are available for many common TimeSeries subtypes, so plotting is usually straightforward:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"import Plots\nusing LaTeXStrings\nPlots.default(:size, (900, 600))\nPlots.default(:left_margin, 16Plots.px)\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"#TimeSeries{<:Ranged} recipe\nPlots.plot(ts_el_cmd; plot_title=\"Elevator Response\", label = \"Command\")\nPlots.plot!(ts_el_pos; label = \"Position\")","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"#TimeSeries{<:AbstractVector{<:Real}} recipe\nPlots.plot(ts_ω; plot_title=\"Angular Velocity\", ylabel=L\"$\\omega \\ (rad/s)$\")","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"#TimeSeries{Real} recipe\nPlots.plot(ts_α; plot_title=\"AoA vs Pitch Angle\", ylabel=L\"$\\alpha, \\ \\theta \\ (rad)$\", label=\"AoA\")\nPlots.plot!(ts_θ; label = \"Pitch Angle\")","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"&nbsp;","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"In addition to individual TimeSeries recipes, you can use the make_plots function to generate a set of typically useful plots from a specific TimeSeries subtype. Here are some examples:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"plots_kin = make_plots(ts.aircraft.vehicle.kinematics)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"plots_kin[:vχγ]","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"plots_dyn = make_plots(ts.aircraft.vehicle.dynamics)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"plots_dyn[:f_c_c]","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"plots_air = make_plots(ts.aircraft.vehicle.airflow)","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"plots_air[:airspeed_M_q]","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"&nbsp;","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"To save all the plots in one of these sets you can do:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"save_plots(plots_kin, normpath(\"tmp/plots/kin\"))\nrm(normpath(\"tmp/plots/kin\"), recursive = true) #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Or, directly from the TimeSeries object:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"save_plots(ts.aircraft.vehicle.kinematics, normpath(\"tmp/plots/kin\"))\nrm(normpath(\"tmp/plots/kin\"), recursive = true) #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/#Automating-Model-Control-With-User-Callbacks","page":"Headless Simulation","title":"Automating Model Control With User Callbacks","text":"","category":"section"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Sometimes, stepping through the Simulation and assigning inputs at each stop is not the best approach for controlling a Model during headless Simulation runs. In many cases, it is cleaner and more convenient to define and encapsulate the control logic in advance, and then let the Simulation run uninterrupted from start to finish.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"This is where user callbacks come in. These are custom functions with the signature user_callback!(::Model) called by the Simulation after every integration step. The main purpose of user callbacks is to automate Model input management.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"warning: Modifying Model State\nUser callbacks should only be used to assign Model inputs; do not modify a Model's continuous or discrete states within a user callback unless you really know what you're doing.","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"Let's define a user callback implementing our elevator doublet logic:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"user_callback! = function(mdl::Model)\n    t = mdl.t[] #mdl.t is a RefValue, we need to dereference it\n    u_lon = mdl.aircraft.avionics.lon.u\n    if 5 <= t < 7\n        u_lon.elevator_offset = 0.1\n    elseif 7 <= t < 9\n        u_lon.elevator_offset = -0.1\n    else\n        u_lon.elevator_offset = 0\n    end\nend","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"All we need to do now is create a new Simulation with this function definition as a keyword argument, initialize it as before, and run it:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"sim = Simulation(mdl; dt = 0.02, t_end = 60, user_callback!)\ninit!(sim, init_air)\nSim.run!(sim)\nnothing #hide","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"As expected, we get exactly the same result:","category":"page"},{"location":"tutorials/tutorial02/tutorial02/","page":"Headless Simulation","title":"Headless Simulation","text":"ts = TimeSeries(sim)\nts_el = ts.aircraft.vehicle.systems.act.elevator[4 .<= get_time(ts) .< 10]\nPlots.plot(ts_el.cmd; plot_title=\"Elevator Response\", label = \"Command\")\nPlots.plot!(ts_el.pos; label = \"Position\")","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#FlightLib","page":"API","title":"FlightLib","text":"","category":"section"},{"location":"api/#Dynamics","page":"API","title":"Dynamics","text":"","category":"section"},{"location":"api/#Flight.FlightLib.Dynamics.FrameTransform","page":"API","title":"Flight.FlightLib.Dynamics.FrameTransform","text":"Specify a reference frame c with respect to another b.\n\nc is defined by:\n\nr_bc^b: Position vector from b's origin O_b to c's origin O_c, projected on b's axes Ɛ_b\nq^b_c: Rotation quaternion from b's axes Ɛ_b to c's axes Ɛ_c\n\nFrameTransform objects are callable; the syntax t_bc(x_c) is equivalent to translate(t_bc, x_c).\n\n\n\n\n\n","category":"type"},{"location":"api/#Flight.FlightLib.Dynamics.translate-Tuple{FrameTransform, AbstractVector{<:Real}}","page":"API","title":"Flight.FlightLib.Dynamics.translate","text":"translate(t_bc::FrameTransform, r_cP_c::AbstractVector{<:Real})\n\nTranslate a 3D position vector from one reference frame to another.\n\nGiven the FrameTransform t_bc from frame b to frame c and the position vector of some point P in c (r_cP^c), return the position vector of P in b (r_bP^b).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.adjoint-Tuple{FrameTransform}","page":"API","title":"Base.adjoint","text":"Base.:adjoint(t_bc::FrameTransform)\n\nGiven t_bc, return its reciprocal t_cb.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:∘-Tuple{FrameTransform, FrameTransform}","page":"API","title":"Base.:∘","text":"Base.:∘(t_bc::FrameTransform, t_cd::FrameTransform)\n\nConcatenate FrameTransforms t_bc and t_cd and return the resulting t_bd.\n\n\n\n\n\n","category":"method"},{"location":"api/#Flight.FlightLib.Dynamics.Wrench","page":"API","title":"Flight.FlightLib.Dynamics.Wrench","text":"Force and torque combination defined in a specific reference frame.\n\nA Wrench is defined in frame c when it is applied at c's origin O_c and projected on its axes Ɛ_c\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"reference/core/modeling/#Modeling","page":"Modeling","title":"Modeling","text":"","category":"section"},{"location":"reference/core/modeling/#Overview","page":"Modeling","title":"Overview","text":"","category":"section"},{"location":"reference/core/modeling/#Philosophy:-Performance,-Control,-and-Transparency","page":"Modeling","title":"Philosophy: Performance, Control, and Transparency","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The Modeling module is the cornerstone of Flight.jl. It provides a lightweight, flexible and high-performance framework, which enables creating complex systems from simpler, reusable components in a hierarchical fashion.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"This modeling framework is causal and imperative. It is domain-agnostic by design, but it is tailored to / heavily oriented towards its primary goals: GNC algorithm development and real-time simulation.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"It can be understood as a generalization of the classic state-space representation used in control engineering and other disciplines. Shares the same input, state, output, but generalized to accomodate nonlinear and discrete dynamics state-space oriented, which is a good fit for most tasks within the GNC domain","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"In essence, modeling.jl is not a symbolic modeling system; it is a framework for organizing imperative, state-space code into a composable hierarchy.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"This framework was developed specifically to meet the requirements of guidance, navigation & control applications. Its minimalistic design is a deliberate choice prioritizing ultimate performance, fine-grained control, and architectural transparency. absolute control","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The user explicitly:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Specifies the properties of each component: input, output, continuous state, etc.\nWrites the Julia code within the update functions that define the system's dynamics.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"This approach places a greater responsibility on the user to achieve performant, efficient code. In return, it grants absolute control and predictability, which are desirable for real-time simulation and deep systems analysis.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"This is different from the acausal, symbolic and declarative paradigm of modeling frameworks like ModelingToolkit.jl.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Its capabilities are less general","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"For the specific domain of real-time, high-fidelity aircraft GNC simulation, where the underlying physics are well-described by causal ODEs and performance is paramount, this is an excellent and highly justifiable engineering choice","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"favors","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Do focus on what ModelingToolkit.jl is or is not. Focus on describing what Flight.jl does.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"While Julia's ecosystem offers the powerful ModelingToolkit.jl (MTK) for acausal modeling, Flight.jl uses a custom, causal framework for several deliberate reasons that are critical to its design goals:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Guaranteed, Hand-Tuned Performance: The causal approach gives the developer absolute control  over the computational path in the performance-critical model update functions. This allows for  manual optimization to guarantee a type-stable, zero-allocation simulation loop, which is  essential for real-time applications and large-scale analysis.\nIntuitive for GNC Algorithm Design: The signal-flow paradigm is the natural mental model  for control engineers. The explicit definition of inputs, outputs, and discrete update logic  (f_periodic!) maps directly to the implementation of digital flight control and guidance  systems.\nSimplicity and Transparency: The framework's abstractions are simple and direct. A Model  is just a Julia struct, and its dynamics are just Julia functions. This makes the entire  system highly transparent and easy to debug with standard Julia tools.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"In summary, Flight.jl's modeling framework is a specialized tool designed for a specific job. It trades the generality and automatic code generation of symbolic systems for the raw performance, transparency, and control of a carefully crafted imperative structure.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"State-space","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Flight dynamics modeling tasks fit very well","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"This guide explains the core concepts of the framework and the \"performance contract\" you implicitly agree to when creating new components.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Flight.jl employs a causal (or signal-flow) modeling paradigm. This means the flow of computation is explicitly defined by the developer. Every Model must adhere to a standardized interface of update functions that define its behavior:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"In essence, Flight.jl's framework is not an attempt to reinvent a general-purpose modeling language. It is a specialized, domain-specific tool forged for the express purpose of building the most performant and flexible flight simulation systems possible in Julia.","category":"page"},{"location":"reference/core/modeling/#Core-Concepts:-Blueprints-and-Instances","page":"Modeling","title":"Core Concepts: Blueprints and Instances","text":"","category":"section"},{"location":"reference/core/modeling/#The-ModelDefinition-/-Model-Paradigm","page":"Modeling","title":"The ModelDefinition / Model Paradigm","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The framework is built upon two core abstractions:","category":"page"},{"location":"reference/core/modeling/#1.-ModelDefinition:-The-Static-Blueprint","page":"Modeling","title":"1. ModelDefinition: The Static Blueprint","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"A ModelDefinition is a struct that acts as a blueprint for a simulation component. Its purpose is to:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Define the static parameters and constants of the component.\nEstablish the system's hierarchy by including other ModelDefinitions as fields.\nFor example, a Vehicle is defined as having Systems, Kinematics, and Dynamics components:\n```julia\nA simplified conceptual example\nstruct Vehicle <: ModelDefinition      systems::Systems   #<– Child ModelDefinition      kinematics::WA     #<– Child ModelDefinition      dynamics::VehicleDynamics  end  ```\nModelDefinitions are lightweight, compile-time constructs that describe the structure of your  simulation.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"ModelDefinition (The Blueprint): An abstract type for user-defined structs that serve as  a declarative blueprint for a system component. A ModelDefinition specifies a component's  constant parameters and its hierarchical structure by including other ModelDefinitions as  fields.\n```julia  using Flight.FlightCore # Assuming this is where Modeling is exported\nstruct MyActuator <: ModelDefinition      τ::Float64 #A constant parameter (time constant)  end\nstruct MyAircraft <: ModelDefinition      actuator::MyActuator #A sub-component      mass::Float64 #Another constant parameter  end  ```\nModel (The Instance): The concrete, stateful object used by the simulation engine. When a  ModelDefinition is passed to the Model constructor, it recursively builds a tree of Model  instances and allocates the necessary memory for its state, inputs, and outputs.\njulia  aircraft_def = MyAircraft(actuator = MyActuator(τ = 0.1), mass = 1000.0)  aircraft_model = Model(aircraft_def)","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"A Model is the stateful instance of a component used during the simulation. It is created by passing a ModelDefinition to the Model constructor: mdl = Model(my_definition). The Model struct holds the \"live\" data: Every Model instance in the simulation holds five key properties:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"x: The continuous state vector, which is managed by the ODE solver.\nẋ: The continuous state derivative, which is computed by the model's dynamics.\ns: The discrete state, a mutable struct for states that change at discrete time   instances.\nu: The input, a mutable data type for variables that are assigned externally.\ny: The output, an immutable data type holding the results of the Model's computations.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"When a Model is created, the framework recursively constructs Model instances for all its children, creating a tree of interconnected objects. ComponentArrays are used under the hood to ensure that the state vector x of a parent Model is a single, contiguous block of memory composed of the state vectors of its children. This is so that the ODE solver sees the continuous state vector and its derivative as a single, contiguous blocks of memory.","category":"page"},{"location":"reference/core/modeling/#How-to-define-a-Model's-X,-Xdot,-S,-U,-Y","page":"Modeling","title":"How to define a Model's X, Xdot, S, U, Y","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The ModelDefinition struct itself contains fields that are either ModelDefinition subtypes or other types. These end up as parameters and submodels respectively. But, how do you specify the Model's x, xdot, etc?","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"By default, all of these Model properties will be nothing. The only exception is x and x_dot for a node (non-leaf) Model. To specify what you want them to be, you define constructor methods for each of these ModelDescriptors that dispatch on your ModelDefinition subtype. This sounds more complicated than it is. An example: Let's say we want","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The only exception is x and x_dot for a node (non-leaf) Model. You typically should not define Modeling.X for such models. Their x and x dot will be automatically assembled from those of its children, and they will share memory with them.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"struct MyDef <: ModelDefinition end\n\nModeling.X(::MyDef) = zeros(3) #must be an AbstractVector\nModeling.Y(::MyDef) = zeros(SVector{3}) #must be an isbits type\nModeling.U(::MyDef) = Ref(0.0) #can be any mutable type\n\nmdl = MyDef() |> Model\n@show mdl.x\n@show mdl.y\n@show mdl.u\n@show mdl.s\n\nModeling.X(::MyDef) = ComponentVector(a = 0.0, b = zeros(2))","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Modeling.X: for a leaf component, it must return an AbstractVector. If this method is not defined, the leaf component will have no continuous state by default. For a node component, you typically don't need to extend this method; its continuous state vector will be automatically assembled from those of its children, and it will share memory with them. Children","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Modeling Very simple example of composition. Show that","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Question: couldn't the model's parameters and submodels also be specified via method extension? Given that the Model constructor extracts the fields and processes it depending on what they are, why not simply leave the ModelDefinition as an empty struct and define the following functions: Modeling.Constants(::MyDef) Modeling.Submodels(::MyDef)","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The answer is that this would prevent the user from creating different instances of a Model, each one with its own constant parameter values or submodels. The high-level explanation comes from asking the question: what characterizes a specific instance of a Model? Its specific constant parameters, and the specific instances of the submodels it holds. Therefore, these must be left to be specified when creating each instance, so they should not be universally set by method extensions.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"In contrast, for example, we know that for a leaf model, its x will always have the same structure. And for a node model, it will be assembled from its children's x.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"","category":"page"},{"location":"reference/core/modeling/#Hierarchical-Composition-with-ComponentArrays","page":"Modeling","title":"Hierarchical Composition with ComponentArrays","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The framework's power comes from its hierarchical nature. The state vector x of a parent Model is a ComponentVector that is recursively built from the state vectors of its children. This provides two key benefits:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Human-Readable State: You can access the state of any component with an intuitive dot  notation (e.g., aircraft.vehicle.systems.pwp.engine.x.ω).\nPerformance: The entire state vector remains a single, contiguous block of memory, which is  essential for the performance of the ODE solver.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"[NEW] The Model's output y is also constructed hierarchically. After a component's update function is called, its y field is updated. Parent models can then access the outputs of their children via child.y to compute their own y. This bottom-up assembly ensures that all information is current. While this means some output data may be present at multiple levels of the hierarchy, the performance impact is negligible because the output structs are required to be isbits types (immutable and stack-allocated), making these operations extremely fast. It is ultimately the developer's choice which child outputs to propagate upwards. However, since the Simulation log only records the root Model's output, any information that is not included in it will not be saved.","category":"page"},{"location":"reference/core/modeling/#The-Update-Interface:-Causal,-Programmatic-Dynamics","page":"Modeling","title":"The Update Interface: Causal, Programmatic Dynamics","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"f_ode!(model, ...): Defines the continuous dynamics (ẋ = f(x, u, t)). This is called by the   ODE solver at each integration step and is the performance-critical \"hot loop\" of the   simulation.\nf_step!(model, ...): Defines logic that executes after each successful integration step. It   is typically used for discrete state transitions, such as a \"weight-on-wheels\" flag changing   from false to true.\nf_periodic!(model, ...): Defines logic that executes at fixed, discrete time intervals (Δt).   This is the ideal place for implementing digital controllers, guidance laws, and other   discrete-time algorithms.","category":"page"},{"location":"reference/core/modeling/#The-Update-Cycle:-The-API-Contract","page":"Modeling","title":"The Update Cycle: The API Contract","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Every component you create must adhere to a simple but strict API contract by extending a set of standard functions. The simulation engine guarantees when and how these functions are called.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"f_ode!(model, ...) This is the heart of the continuous simulation. It is called multiple times   per integration step by the ODE solver. Its single purpose is to compute the state derivative   model.ẋ based on the current state model.x, inputs model.u, and time model.t. This is   the performance-critical hot loop of your simulation.\nf_periodic!(model, ...) This function is called by the simulation at fixed time intervals   (Δt). It is used to model discrete-time dynamics. This is the correct place for:\nDigital control logic (PIDs, LQRs).\nState machines (e.g., engine_state transitions).\nUpdating gain schedules.\nf_step!(model, ...) This function is called once at the end of every successful ODE   integration step. It is ideal for tasks that must happen after a state update but are not part   of the continuous dynamics, such as re-normalizing a quaternion to prevent numerical drift.\ninit!(model, ...) This is called to set the initial conditions for the model's states (x and   s) and inputs (u) before a simulation run begins.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The @sm_updates macro can be used on a parent ModelDefinition to automatically generate recursive update methods that call the corresponding methods on all its submodels.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"[EXPANDED] These three core methods can be defined with any number of arguments beyond the Model itself, allowing parent models to pass down necessary data (like atmospheric conditions or kinematic data) to their children. However, a root Model—one that is passed directly to the Simulation constructor—must define single-argument versions of these methods. If a root Model needs to interact with the outside world, it should use the package's I/O capabilities (for joysticks, network, etc.) or a user-defined callback, not method arguments.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"[NEW] When extending the periodic update function, developers must define their method for the NoScheduling dispatch type: f_periodic!(::NoScheduling, mdl::Model, args...). The framework uses this dispatch internally to distinguish between user-defined logic and the scheduling mechanism that determines if the logic should run on a given step. Calling f_periodic!(mdl, args...) without the NoScheduling dispatcher will correctly invoke the scheduling logic.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"[EXPANDED] To enable efficient simulation of systems with components operating at different frequencies (e.g., a high-frequency inner-loop controller and a low-frequency guidance system), the framework provides the Subsampled wrapper. By wrapping a ModelDefinition in Subsampled(definition, K), you specify that its f_periodic! function should be called every K-th period of its parent's periodic execution. The absolute sampling period of any component is therefore the product of the root Simulation's Δt and the K multipliers of all Subsampled models in its branch of the hierarchy.","category":"page"},{"location":"reference/core/modeling/#Dispatching-on-Parametric-ModelDefinitions","page":"Modeling","title":"Dispatching on Parametric ModelDefinitions","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"A potential source of perplexity and frustration occurs when working with parametric ModelDefinitions. If MyModelDef is parametric, Julia will NOT dispatch on a method f(::Model{MyModelDef}). One needs to define f(::Model{<:MyModelDef}) instead. This can be a source of perplexity and frustration to anyone not too familiar with the Julia type system.","category":"page"},{"location":"reference/core/modeling/#Parent-Child-Linkage-Options-for-U-and-S","page":"Modeling","title":"Parent-Child Linkage Options for U and S","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"using Flight\nimport .Modeling: U\n\nstruct Leaf <: ModelDefinition end\n\nModeling.U(::Leaf) = [0.0]\n\n@kwdef struct Node1 <: ModelDefinition\na::Leaf = Leaf()\nb::Leaf = Leaf()\nend\n\n@kwdef struct Node2 <: ModelDefinition\na::Leaf = Leaf()\nb::Leaf = Leaf()\nend\n\nU(node::Node1) = (a = U(node.a), b = U(node.b))\nU(node::Node2) = ComponentVector(a = U(node.a), b = U(node.b))\n\nmdl1 = Node1() |> Model\nmdl2 = Node2() |> Model\n\n@assert mdl1.u isa NamedTuple\n@assert mdl1.u.a === mdl1.a.u\n\n@assert mdl2.u isa ComponentVector\n@assert mdl2.u.a === mdl2.a.u #Component mdl.u returns a view into its a block","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"What's happening is that upon construction, mdl.a input u is assigned a view of mdl.u's a block.","category":"page"},{"location":"reference/core/modeling/#The-Performance-Contract:-Your-Responsibility","page":"Modeling","title":"The Performance Contract: Your Responsibility","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"If you care about performance!","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The exceptional performance of Flight.jl is not magic; it comes from a disciplined implementation approach that every developer must follow for their own components. By extending the framework, you agree to this \"performance contract\":","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"!!! warning \"The Performance Contract\" To ensure the high-performance, real-time capabilities of the     simulation, your component implementations must adhere to the following rules.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Be Type-Stable: All functions in the update cycle, especially f_ode!, must be type-stable.  The types of variables should not change within the function. Use tools like @code_warntype to  verify.\nf_ode! Must Not Allocate: The continuous dynamics function is the hot loop. It must not  allocate any memory on the heap.\nUse StaticArrays (SVector, SMatrix) for all small, fixed-size vector and matrix   operations.\nDo not create standard Vectors, Matrixes, or other heap-allocated objects inside   f_ode!.\nIf you need a temporary buffer, pre-allocate it in your ModelDefinition and store it in   model.parameters.\nUse the Right Data Structures:\nDefine your outputs (Y) as immutable (isbits) structs. This avoids allocations when   returning outputs.\nUse ComponentArrays for your state vector (X) to combine performance with readability.\nTest Your Performance: Use the @ballocated macro from BenchmarkTools.jl in your unit  tests to verify that your f_ode! implementation is allocation-free. The Flight.jl source  code provides numerous examples of this.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Adhering to this contract ensures that your custom components integrate seamlessly into the framework without degrading the performance of the entire simulation.","category":"page"},{"location":"reference/core/modeling/#Detailed-explanation-for-Model-state-vector-assembly","page":"Modeling","title":"Detailed explanation for Model state vector assembly","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Excellent question. This is arguably the most elegant and crucial part of the entire framework, and it's powered by the magic of ComponentArrays.jl. Let's walk through the process step-by-step.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The core idea is a two-pass process:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"First Pass (Assembly): Recursively walk the ModelDefinition hierarchy from the bottom up to determine the shape and size of the complete state vector for the root model. This creates a single, contiguous ComponentVector.\nSecond Pass (Assignment): Recursively walk the hierarchy from the top down to build the Model instances. Each Model instance is given a view (or more accurately, a property accessor that behaves like a view) into the relevant slice of the single ComponentVector created in the first pass.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Let's illustrate with a simple example hierarchy:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"# 1. Define the blueprints (ModelDefinitions)\n\n# The simplest component, a \"leaf\" in our hierarchy\nstruct Leaf <: ModelDefinition end\n# A leaf's state is a simple Vector. This is the base case for our recursion.\nModeling.X(::Leaf) = [0.0]\n\n# A composite component, a \"node\"\nstruct Node <: ModelDefinition\n    leaf_C::Leaf = Leaf()\n    leaf_D::Leaf = Leaf()\nend\n\n# The top-level component, the \"root\"\nstruct Root <: ModelDefinition\n    leaf_A::Leaf = Leaf()\n    node_B::Node = Node()\nend","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Our hierarchy looks like this:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Root\n├── leaf_A (Leaf)\n└── node_B (Node)\n    ├── leaf_C (Leaf)\n    └── leaf_D (Leaf)","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Now, let's trace what happens when we call Model(Root()).","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"","category":"page"},{"location":"reference/core/modeling/#Pass-1:-Assembling-the-State-Vector-(Bottom-Up)","page":"Modeling","title":"Pass 1: Assembling the State Vector (Bottom-Up)","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The entry point is Model(Root()). The very first thing this constructor needs to know is the complete state vector for a Root model. It finds this by calling X(Root()).","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Step 1.1: X(Root()) is called.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The default implementation of X for a composite ModelDefinition does the following:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"It finds all fields that are themselves ModelDefinitions (here, :leaf_A and :node_B).\nIt recursively calls X() on each of them.\nIt assembles the results into a ComponentVector.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"So, X(Root()) triggers two calls:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"X(mdl.leaf_A) which is X(Leaf())\nX(mdl.node_B) which is X(Node())","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Step 1.2: Base Case - X(Leaf())","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"This is the base case of our recursion. We have explicitly defined Modeling.X(::Leaf) = [0.0]. So, this call simply returns [0.0]. The recursion for this branch stops.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Step 1.3: Recursive Call - X(Node())","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Just like X(Root()), the X(Node()) method finds its own children ModelDefinitions (:leaf_C and :leaf_D) and calls X() on them.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"X(mdl.leaf_C) calls X(Leaf()) and gets [0.0].\nX(mdl.leaf_D) calls X(Leaf()) and gets [0.0].","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Now, X(Node()) assembles these results into a ComponentVector, using the field names as keys: ComponentVector(leaf_C = [0.0], leaf_D = [0.0]). This object has a named structure but stores its data in a flat, contiguous vector: [0.0, 0.0].","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Step 1.4: Final Assembly in X(Root())","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The execution now returns to the top-level call, X(Root()). It has received the results from its children:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"From leaf_A: [0.0]\nFrom node_B: ComponentVector(leaf_C = [0.0], leaf_D = [0.0])","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"It assembles these into the final, complete ComponentVector for the entire hierarchy: x_root = ComponentVector(leaf_A = [0.0], node_B = (leaf_C = [0.0], leaf_D = [0.0]))","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Crucially, x_root is a single object whose data is stored in a single, contiguous block of memory: [0.0, 0.0, 0.0]. The nested naming (x_root.node_B.leaf_C) is just a convenient and efficient way to access slices of this underlying flat vector. This answers your \"contiguous in memory\" question. The ODE solver will only ever see this single, flat Vector{Float64}.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"","category":"page"},{"location":"reference/core/modeling/#Pass-2:-Assigning-Views-to-Model-Instances-(Top-Down)","page":"Modeling","title":"Pass 2: Assigning Views to Model Instances (Top-Down)","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Now that the master state vector x_root is created, the Model constructor can create the instances.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Step 2.1: The Root Model is Created","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"A Model{Root} instance is created. Its x field is assigned the complete x_root ComponentVector we just built.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Step 2.2: The Children Models are Created","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The Model(Root()) constructor now iterates through its children ModelDefinitions (leaf_A and node_B) to create their Model instances.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"For leaf_A: It creates a Model{Leaf}. For the x field of this child model, it does not create a new vector. Instead, it passes x_root.leaf_A. This is the key step. x_root.leaf_A is not a copy; it's a \"view\" or a \"property accessor\" into the first element of x_root's underlying data. The leaf_A model now holds a direct reference to its slice of the master state vector.\nFor node_B: It creates a Model{Node}. For its x field, it passes x_root.node_B. This is a view into the last two elements of x_root's data.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Step 2.3: The Grandchildren Models are Created","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The process continues recursively. When the Model{Node} for node_B is being constructed, it in turn looks at its own children:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"For leaf_C: It creates a Model{Leaf}. It receives the view x_root.node_B from its parent. It then passes (x_root.node_B).leaf_C to its child leaf_C. This is a view into the second element of the master x_root vector.\nFor leaf_D: It does the same, passing (x_root.node_B).leaf_D to its child leaf_D, which is a view into the third element of x_root.","category":"page"},{"location":"reference/core/modeling/#The-Final-Result","page":"Modeling","title":"The Final Result","text":"","category":"section"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"After the constructor finishes, we have a tree of Model objects.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"The root_model holds the one and only complete, contiguous state vector: x_root.\nEvery child, grandchild, and so on, holds an x field that is simply a lightweight view pointing to its designated section within that single master vector.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"When the ODE solver updates the state, it modifies the elements of x_root. Because all submodels hold views into this same block of memory, they all instantly see the updated state without any copying or communication required.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Conversely, when a leaf model like leaf_C computes its derivative in f_ode! and writes to its ẋ field, it is actually modifying the specific slice of the root model's ẋ vector that corresponds to its state.","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"This design is brilliant because it combines:","category":"page"},{"location":"reference/core/modeling/","page":"Modeling","title":"Modeling","text":"Readability: You can access any state from the top down with a clean, hierarchical syntax (root_model.node_B.leaf_C.x).\nPerformance: There is only one block of memory for the entire state, making it extremely friendly to the ODE solver and the CPU cache.\nComposability: The logic for defining the shape of the state (X(::MyDef)) is local to each component, but the framework automatically assembles it into a global, performant structure.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/#Interactive-Simulation","page":"Interactive Simulation","title":"Interactive Simulation","text":"","category":"section"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"This tutorial shows how to set up and run an interactive aircraft simulation. You will be able to control it through the built-in GUI and, optionally, use the free X-Plane 12 demo for 3D visualization.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/#Setting-Up-X-Plane-12","page":"Interactive Simulation","title":"Setting Up X-Plane 12","text":"","category":"section"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Download, install and run the X-Plane 12 demo. If you happen to have the full version, you can use it instead. Since we will be running X-Plane simply as an external visualization tool, we only need to set up a few things; for further help, check out the X-Plane 12 manual.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"note: No X-Plane?\nIf you can't run X-Plane 12 (which might happen for instance if you have an Intel integrated graphics chip), you can skip this section. Your visuals will be limited to the built-in GUI, but everything else should still work.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"From the main menu, click on New Flight. Select the Cessna Skyhawk as your aircraft and Salzburg (LOWS) as your initial location. Start the flight.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: X-Plane 12 New Flight Screen)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Once X-Plane is done loading, move the mouse to the top of the screen to bring up the menu bar. Click on the Settings icon and go the Network tab. Make sure Accept incoming connections is enabled. Then, under the UDP Ports section, check the Port we receive on (legacy) value. The default is 49000, but you can use a different one if you need to. Finally, if you are running X-Plane on a different machine than your Julia session, note its IP address.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: X-Plane 12 Network Settings)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Now go to the Graphics tab. Unless you have a multi-monitor setup, you will probably want to run X-Plane in windowed mode. This will allow you to keep it on screen along with the Flight.jl built-in GUI. To enable windowed mode, select Windowed Simulator in the Monitor usage drop-down.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: X-Plane 12 Graphics Settings)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"You might also want to experiment with the quality settings until you achieve a comfortable framerate. To display the framerate on screen, go to the Data Output tab, find the Framerate entry in the table and enable the Show in cockpit option.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: X-Plane 12 Data Output)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"To switch to an external camera, press Shift+4. You can right click and drag to rotate the view and use the mouse wheel to zoom in and out. To return to the cockpit camera, press Shift+0.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: X-Plane 12 External)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"This concludes our X-Plane setup, now let's move on to Julia.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/#Setting-Up-the-Flight.jl-Simulation","page":"Interactive Simulation","title":"Setting Up the Flight.jl Simulation","text":"","category":"section"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"warning: On Multithreading\nTo work through this example, you will need to start Julia with multiple threads enabled.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Let's begin by initializing the package:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"using Flight","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Next, we need to define a 2D location and orthometric elevation for the beginning of Salzburg airport's runway 15, as well as the runway's geographic heading:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"loc_LOWS15 = LatLon(ϕ = deg2rad(47.80433), λ = deg2rad(12.997))\nh_LOWS15 = HOrth(427.2)\nψ_LOWS15 = deg2rad(157)\nnothing # hide","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"note: A Caveat On X-Plane Visuals\nThe above values will result in X-Plane displaying the aircraft properly positioned and aligned on the runway centerline at the beginning of the simulation. However, this is just for aesthetics, since our simulation's physics are totally independent from X-Plane's terrain mesh. This disconnect will become apparent as soon as the aircraft starts rolling down the runway.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Now, let's create our simulated world:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"aircraft = Cessna172Xv1()\natmosphere = SimpleAtmosphere()\nterrain = HorizontalTerrain(h_LOWS15)\nworld = SimpleWorld(aircraft, atmosphere, terrain)\nnothing # hide","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"SimpleAtmosphere provides a basic, ISA-based atmosphere with customizable sea-level conditions and wind velocity. HorizontalTerrain represents a surface with constant orthometric elevation, which we have set to our value for the beginning of runway 15. Finally, Cessna172Xv1 is a hypothetical customization of a Cessna 172S. It replaces the reversible actuation system on the base model with a digital fly-by-wire flight control system, which we will leverage in this example. Note that this aircraft does not aim to replicate the internals or interface of any specific real-world autopilot. Its purpose is simply to illustrate how the Flight.jl framework may be used to design, implement and test complex control architectures.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"We can now build our simulation:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"sim = Simulation(world; dt = 0.01) #specifies a suitable integration step size\nnothing # hide","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Under the hood, this call turns our SimpleWorld instance into a Model object, which is what the Simulation will actually interact with. The Model type is central to the Flight.jl framework, and we will look into it further in future examples.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Next, we instantiate an X-Plane 12 control interface and attach it to the simulation. This will allow the simulation to disable X-Plane's physics engine and periodically send our aircraft's state for X-Plane to display:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"xp = XPlane12Control()\nSim.attach!(sim, xp)\nnothing # hide","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"note: X-Plane UDP Settings\nThe default XPlane12Control constructor assumes X-Plane 12 is running on your local machine and listening on port 49000. If this is not the case, you will need to provide the appropriate IP address and/or port (discussed in the X-Plane setup section) as keyword arguments. For example:using Flight # hide\nusing Sockets #bring IPv4 into scope\nxp = XPlane12Control(address = IPv4(\"192.168.1.2\"), port = 49001)\nnothing # hide","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Flight.jl provides a generic joystick interface built on SDL2_jll. Currently, Thrustmaster's T.16000M and VKBSim's Gladiator NXT Evo are the only supported models. If you happen to own one of these, you can plug it in now and do the following:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"for joystick in update_connected_joysticks()\n    Sim.attach!(sim, joystick)\nend","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Otherwise, don't worry; in this example, we will let the SAS and autopilot modes handle most of the flying for us. This will make it relatively easy to control the aircraft through the GUI.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"The last step is to define a suitable initial condition. For on-ground initialization, we can do that by specifying the aircraft's frame kinematic state:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"init_gnd = KinInit(;\n    location = loc_LOWS15, #2D location\n    h = h_LOWS15 + C172.Δh_to_gnd, #altitude, as an offset with respect to terrain elevation\n    q_nb = REuler(ψ_LOWS15, 0, 0), #attitude with respect to NED frame, as Euler angles\n    ω_wb_b = zeros(3), #angular velocity with respect to local tangent frame, aircraft frame coordinates\n    v_eb_n = zeros(3), #Earth-relative velocity, NED frame coordinates\n    ) |> C172.Init\nnothing # hide","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Then, we assign it as:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"init!(sim, init_gnd)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/#Running-the-Simulation","page":"Interactive Simulation","title":"Running the Simulation","text":"","category":"section"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Now we can finally run the simulation:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Sim.run!(sim; gui = true)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"After a few seconds, the simulation will start, and a new OS window containing the built-in GUI will open:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: Default GUI)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"The Simulation Control panel lets you pause or resume the simulation, and set its pace relative to wall clock time. To abort the simulation, simply close the GUI window.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"The other panel is specific to the simulated Model. A complex Model like ours comprises a hierarchy of components. Each component is itself a Model, and it typically defines its own GUI panel, which can be accessed from that of its parent. Feel free to explore the GUI to get a picture of the underlying component hierarchy and discover different ways of interacting with the simulation.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"tip: GUI State\nGUI panels can be moved, resized, tiled, docked or grouped as tabs. Try to find the layout that works best for you. GUI state is saved in a file named imgui.ini, which is automatically created in the project's root folder.  Deleting this file will restore the GUI to its default state.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Let's get back to X-Plane for a moment. You should now see the aircraft sitting on the runway with the engine stopped. This indicates that the X-Plane interface was set up properly and our simulation has taken control of the visuals.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: X-Plane 12 Simulation Started)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"note: X-Plane 12 Demo Time Limit\nAs of this writing, the X-Plane 12 demo is time-limited to 60 minutes. After that, an on-screen pop-up will appear. To get rid of it, you can simply restart X-Plane and click on Resume Last Flight. Then, reset the simulation and run it again:init!(sim, init_gnd)\nSim.run!(sim; gui = true)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Now return to the GUI and navigate to Aircraft > Vehicle > Systems > Power Plant > Engine. Expand the Control header and press the Engine Start button. To confirm the engine is running, you can check the engine parameters under the Data header.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: GUI Engine Start)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"If you now try to drag the Throttle slider, you will notice it does not move. The reason is that, on this aircraft, throttle is controlled through the fly-by-wire flight control system.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"You can find the flight control system's interface under Aircraft > Avionics. Expand its Longitudinal Control and Lateral Control sections. The longitudinal control channel computes throttle and elevator commands. The lateral control channel computes aileron and rudder commands. Both are initialized in Direct mode, wherein each actuator command is simply the sum of its corresponding Axis and Offset values. With Direct mode active on both channels, you are essentially flying the base Cessna 172S model, except for the additional actuator dynamics.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Try moving the control surfaces using the Axis and Offset inputs, and observe the result on the GUI's numerical displays or an external X-Plane camera. When you are done, reset all values back to zero.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"note: Joystick Override\nIf you have a joystick attached, the Axis sliders will be overridden by the corresponding joystick axes.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"tip: Keyboard Input\nTo assign a precise value to a control slider, use Ctrl+Click (on Windows) or Cmd+click (on Mac) to enable keyboard input.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Under Longitudinal Control, select the SAS mode. In this mode, throttle and elevator inputs are fed to a longitudinal stability compensator, which computes the actual throttle and elevator actuator commands. This modifies the natural short-period and phugoid modes, providing a smoother, more stable pitch response. When clicked, the button will turn amber, indicating the mode is now on standby; it will engage automatically upon lift off.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Under Lateral Control, select the SAS mode. In this mode, aileron and rudder inputs are fed to a lateral stability compensator, which computes the actual aileron and rudder actuator commands. This improves the aircraft's Dutch roll response and stabilizes its naturally unstable spiral mode.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Currently, the GUI does not have a graphical instrument panel. Instead, the Flight Data section provides readouts for all essential variables. This will be particularly useful if you're running this example without X-Plane.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: Take-Off GUI)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"That is all we really need to set up for take off. We won't bother with flap settings, rotation or even keeping the aircraft centered on the runway (which, as far as our simulation is concerned, doesn't really exist!). When you're ready, just set the Throttle Axis all the way to 1 and let the aircraft accelerate and lift off on its own.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Once airborne, you will see the previously selected SAS modes turn from amber to green. Let the aircraft climb for a while to give yourself some clearance. Then, spend some time flying with the SAS modes enabled. When you feel comfortable with the controls, try switching back and forth between the Direct and SAS longitudinal modes, and compare the aircraft's response to elevator input. You can do the same with the Direct and SAS lateral modes to compare aileron and rudder responses, but mind the spiral mode instability!","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"tip: Crashing\nIf the landing gear model detects a crash, it will throw an exception and the simulation will abort. No worries, just reset it and have another go.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Next, try the EAS + Pitch Rate mode. This mode combines an autothrottle loop with a pitch rate loop built on top of the longitudinal SAS. Activating this mode will disable all Throttle and Elevator inputs and enable the EAS and Pitch Rate commands. The numerical readout to the right of each command slider shows the current value of its target variable. Try changing the EAS command and observe the response. Then, experiment with the Pitch Rate command. While doing so, keep in mind that an arbitrary pitch rate cannot be sustained indefinitely!","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"note: Mode Transitions\nWhen a new autopilot mode is engaged, its command variables are automatically set to their current values to provide a smooth transition. The exception are Pitch Rate and Roll Rate commands, which are always initialized to zero.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"When you are done, enable the EAS + Altitude Hold mode and set the EAS command to 50 m/s. This will hold your altitude throughout the next steps.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"If you have attempted any turns so far, you may have noticed that the Roll/Yaw SAS mode does not provide automatic turn coordination. For this, you can use one of the higher level lateral modes, all of which track sideslip angle commands. Go ahead and enable the Bank Angle + Sideslip mode. Set the Sideslip Angle command to zero. Then, initiate a turn with the Bank Angle command, and notice how the sideslip angle is indeed held during the turn.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Finally, enable the Course Angle + Sideslip mode. Set the Course Angle to 0 and let the aircraft turn to intercept it. Then, open the Atmosphere > Wind panel. Use the East slider to add some crosswind. Notice how the aircraft turns into the wind, settling on the appropriate heading to maintain the commanded course angle, while also tracking the commanded sideslip angle.","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"(Image: Course Tracking GUI)","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"Feel free to explore the remaining control modes on your own. One final hint before wrapping up: if the take-off sequence starts getting tedious, you can skip it entirely by using the trim functionality to initialize the aircraft in flight. Here's how to do it:","category":"page"},{"location":"tutorials/tutorial01/tutorial01/","page":"Interactive Simulation","title":"Interactive Simulation","text":"init_air = C172.TrimParameters(;\n    Ob = Geographic(loc_LOWS15, h_LOWS15 + 500), #500 m above runway 15\n    EAS = 50.0, #equivalent airspeed (m/s)\n    ψ_nb = ψ_LOWS15, #runway heading (rad)\n    γ_wb_n = 0.0, #wind-relative flight path angle (rad)\n    ψ_wb_dot = 0.0, #turn rate (rad/s)\n    flaps = 0.0, #flaps position (0 to 1)\n    fuel_load = 0.5, #normalized fuel load (0 to 1)\n)\ninit!(sim, init_air)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Flight\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Configuring Julia for Multithreading\nDuring simulation, Flight.jl uses multithreading to concurrently handle the simulation loop, the built-in GUI and any attached I/O devices. Therefore, if you intend to use its interactive or I/O capabilities, you will need to start Julia with multiple threads enabled. You can find out how to do this in the manual. However, if you are using the Julia extension for VS Code, the easiest way is to add the following entry to your settings.json:\"julia.additionalArgs\": [\n    \"--threads=auto\",\n],This should work well for most CPUs and use cases. If you run into issues, you can set the number of threads manually to cover your specific needs.","category":"page"}]
}
