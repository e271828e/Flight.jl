<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Headless Simulation · Flight.jl</title><meta name="title" content="Headless Simulation · Flight.jl"/><meta property="og:title" content="Headless Simulation · Flight.jl"/><meta property="twitter:title" content="Headless Simulation · Flight.jl"/><meta name="description" content="Documentation for Flight.jl."/><meta property="og:description" content="Documentation for Flight.jl."/><meta property="twitter:description" content="Documentation for Flight.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Flight.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorial01/tutorial01/">Interactive Simulation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Headless Simulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Headless Simulation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/e271828e/Flight.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/e271828e/Flight.jl/blob/master/docs/src/tutorials/tutorial02/tutorial02.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Headless-Simulation"><a class="docs-heading-anchor" href="#Headless-Simulation">Headless Simulation</a><a id="Headless-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Headless-Simulation" title="Permalink"></a></h1><p>In this tutorial, we revisit our <a href="../../tutorial01/tutorial01/#Interactive-Simulation">interactive simulation</a> setup. This time, we will learn how to run the <code>Simulation</code> programmatically and extract results for inspection and plotting.</p><h3 id="Peeking-Into-the-Model"><a class="docs-heading-anchor" href="#Peeking-Into-the-Model">Peeking Into the <code>Model</code></a><a id="Peeking-Into-the-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Peeking-Into-the-Model" title="Permalink"></a></h3><p>Let&#39;s start from a new <code>SimpleWorld</code> instance. Here, keeping consistency with X-Plane&#39;s visuals is no longer a concern, so we can stick to the default constructors:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Flight</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; world = SimpleWorld(Cessna172Xv1(), SimpleAtmosphere(), HorizontalTerrain())</code><code class="nohighlight hljs ansi" style="display:block;">SimpleWorld{Flight.FlightLib.AircraftBase.Aircraft{Flight.FlightLib.AircraftBase.Vehicle{Flight.Flig...(...)</code></pre><p>Inspecting its type hierarchy reveals that <code>SimpleWorld</code> is a concrete subtype of the abstract type <code>ModelDefinition</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using InteractiveUtils</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supertypes(SimpleWorld)</code><code class="nohighlight hljs ansi" style="display:block;">(SimpleWorld, AbstractWorld, ModelDefinition, Any)</code></pre><p>An instance of a <code>ModelDefinition</code> subtype can be thought of as a blueprint specifying how a particular <code>Model</code> should be built. To instantiate this <code>Model</code>, we pass the <code>ModelDefinition</code> object to the <code>Model</code> constructor:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mdl = Model(world)</code><code class="nohighlight hljs ansi" style="display:block;">Model{SimpleWorld{Flight.FlightLib.AircraftBase.Aircraft{Flight.FlightLib.AircraftBase.Vehicle{Flight.Flig...}(...)</code></pre><p>Let&#39;s take a look at our <code>Model</code>&#39;s properties:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; propertynames(mdl)</code><code class="nohighlight hljs ansi" style="display:block;">(:x, :ẋ, :s, :u, :y, :t, :Δt, :constants, :submodels, :aircraft, :atmosphere, :terrain)</code></pre><p>Here&#39;s a brief description of each one:</p><ul><li><code>x</code> (<em>continuous state</em>): A vector containing <code>Model</code> states that evolve continuously over time. It is updated by the <code>Simulation</code>&#39;s ODE integrator.</li><li><code>ẋ</code> (<em>continuous state derivative</em>): A vector containing the time derivative of <code>x</code>.</li><li><code>s</code> (<em>discrete state</em>): A mutable type holding <code>Model</code> states that change only at specific moments in time.</li><li><code>u</code> (<em>input</em>): A mutable type holding the <code>Model</code>&#39;s input variables. These are assigned either by a parent <code>Model</code> or an external source.</li><li><code>y</code> (<em>output</em>): An immutable type holding all the relevant results from the <code>Model</code>&#39;s computations. These may be used by a parent <code>Model</code> or saved in the <code>Simulation</code>&#39;s log.</li><li><code>t</code> (<em>time</em>): A reference to the current simulation time.</li><li><code>Δt</code> (<em>sampling period</em>): The time interval for the <code>Model</code>&#39;s periodic updates.</li><li><code>constants</code>: A <code>NamedTuple</code> containing <code>Model</code> parameters that do not change during simulation.</li><li><code>submodels</code>: A <code>NamedTuple</code> of child <code>Model</code>s that represent components of the parent <code>Model</code>.</li></ul><p>The remaining properties are entries from <code>constants</code> and <code>submodels</code>. These may be accessed directly via dot notation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(mdl.constants)</code><code class="nohighlight hljs ansi" style="display:block;">()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(mdl.submodels)</code><code class="nohighlight hljs ansi" style="display:block;">(:aircraft, :atmosphere, :terrain)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mdl.atmosphere</code><code class="nohighlight hljs ansi" style="display:block;">Model{SimpleAtmosphere{TunableSeaLevel, TunableWind}}(...)</code></pre><p>A submodel can have submodels of its own:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; keys(mdl.atmosphere.submodels)</code><code class="nohighlight hljs ansi" style="display:block;">(:sl, :wind)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mdl.atmosphere.sl</code><code class="nohighlight hljs ansi" style="display:block;">Model{TunableSeaLevel}(...)</code></pre><p>Thus, a complex <code>Model</code> can be made up of multiple, hierarchically arranged components, each one of them itself a <code>Model</code>. To visualize a <code>Model</code>&#39;s hierarchy, you can use the <code>print_tree</code> function. For example, let&#39;s see what&#39;s underneath the <code>mdl.aircraft.vehicle.ctl</code> node:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using AbstractTrees</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_tree(mdl.aircraft.avionics.ctl; maxdepth = 10)</code><code class="nohighlight hljs ansi" style="display:block;">Model{Flight.FlightAircraft.C172.C172X.C172XControl.Controller{Flight.FlightAircraft.C172.C172X.C172XContr...}(...)
├─ :lon_ctl ⇒ Model{Flight.FlightAircraft.C172.C172X.C172XControl.LonControl{Flight.FlightLib.Control.Discrete.LQRTracke...}(...)
│             ├─ :e2e_lqr ⇒ Model{Flight.FlightLib.Control.Discrete.LQRTracker{6, 1, 1, 6, 1}}(...)
│             ├─ :q2e_int ⇒ Model{Flight.FlightLib.Control.Discrete.Integrator}(...)
│             ├─ :q2e_pid ⇒ Model{Flight.FlightLib.Control.Discrete.PID}(...)
│             ├─ :v2θ_pid ⇒ Model{Flight.FlightLib.Control.Discrete.PID}(...)
│             ├─ :c2θ_pid ⇒ Model{Flight.FlightLib.Control.Discrete.PID}(...)
│             └─ :v2t_pid ⇒ Model{Flight.FlightLib.Control.Discrete.PID}(...)
├─ :lat_ctl ⇒ Model{Flight.FlightAircraft.C172.C172X.C172XControl.LatControl{Flight.FlightLib.Control.Discrete.LQRTracke...}(...)
│             ├─ :ar2ar_lqr ⇒ Model{Flight.FlightLib.Control.Discrete.LQRTracker{8, 2, 2, 16, 4}}(...)
│             ├─ :φβ2ar_lqr ⇒ Model{Flight.FlightLib.Control.Discrete.LQRTracker{8, 2, 2, 16, 4}}(...)
│             ├─ :p2φ_int ⇒ Model{Flight.FlightLib.Control.Discrete.Integrator}(...)
│             ├─ :p2φ_pid ⇒ Model{Flight.FlightLib.Control.Discrete.PID}(...)
│             └─ :χ2φ_pid ⇒ Model{Flight.FlightLib.Control.Discrete.PID}(...)
├─ :alt_gdc ⇒ Model{Flight.FlightAircraft.C172.C172X.C172XControl.AltitudeGuidance}(...)
└─ :seg_gdc ⇒ Model{Flight.FlightAircraft.C172.C172X.C172XControl.SegmentGuidance}(...)</code></pre><p>You can also inspect a specific property across a <code>Model</code>&#39;s hierarchy. For instance, to view the discrete state of <code>mdl.aircraft.avionics.ctl</code> and every node underneath:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_tree(mdl.aircraft.avionics.ctl, :s; maxdepth = 10);</code><code class="nohighlight hljs ansi" style="display:block;">nothing
├─ :lon_ctl ⇒ nothing
│             ├─ :e2e_lqr ⇒ Flight.FlightLib.Control.Discrete.LQRTrackerState{6, 1}([0.0], [0])
│             ├─ :q2e_int ⇒ Flight.FlightLib.Control.Discrete.IntegratorState(0.0, 0)
│             ├─ :q2e_pid ⇒ Flight.FlightLib.Control.Discrete.PIDState(0.0, 0.0, 0)
│             ├─ :v2θ_pid ⇒ Flight.FlightLib.Control.Discrete.PIDState(0.0, 0.0, 0)
│             ├─ :c2θ_pid ⇒ Flight.FlightLib.Control.Discrete.PIDState(0.0, 0.0, 0)
│             └─ :v2t_pid ⇒ Flight.FlightLib.Control.Discrete.PIDState(0.0, 0.0, 0)
├─ :lat_ctl ⇒ nothing
│             ├─ :ar2ar_lqr ⇒ Flight.FlightLib.Control.Discrete.LQRTrackerState{8, 2}([0.0, 0.0], [0, 0])
│             ├─ :φβ2ar_lqr ⇒ Flight.FlightLib.Control.Discrete.LQRTrackerState{8, 2}([0.0, 0.0], [0, 0])
│             ├─ :p2φ_int ⇒ Flight.FlightLib.Control.Discrete.IntegratorState(0.0, 0)
│             ├─ :p2φ_pid ⇒ Flight.FlightLib.Control.Discrete.PIDState(0.0, 0.0, 0)
│             └─ :χ2φ_pid ⇒ Flight.FlightLib.Control.Discrete.PIDState(0.0, 0.0, 0)
├─ :alt_gdc ⇒ Flight.FlightAircraft.C172.C172X.C172XControl.AltitudeGuidanceS(Flight.FlightAircraft.C172.C172X.C172XControl.alt_hold, 10.0)
└─ :seg_gdc ⇒ nothing</code></pre><h3 id="Simulating-an-Elevator-Doublet"><a class="docs-heading-anchor" href="#Simulating-an-Elevator-Doublet">Simulating an Elevator Doublet</a><a id="Simulating-an-Elevator-Doublet-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-an-Elevator-Doublet" title="Permalink"></a></h3><p>Our plan in this section is as follows:</p><ol><li>Initialize the aircraft in a trimmed state.</li><li>Inject an elevator doublet by setting the appropriate inputs and stepping the <code>Simulation</code> manually.</li><li>Let the <code>Simulation</code> run to completion.</li><li>Extract and plot some useful variables from the <code>Simulation</code>&#39;s log to observe the aircraft&#39;s response.</li></ol><p>Let&#39;s first create a <code>Simulation</code> from our <code>Model</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sim = Simulation(mdl; dt = 0.02, t_end = 60)</code><code class="nohighlight hljs ansi" style="display:block;">Simulation{SimpleWorld{Flight.FlightLib.AircraftBase.Aircraft{Flight.FlightLib.AircraftBase.Vehicle{Flight.Flig...}(...)</code></pre><p>The <code>Model</code> is now stored within the <code>Simulation</code>. It can be accesed at any time for inspection or manipulation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; :mdl ∈ propertynames(sim)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sim.mdl === mdl</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>We could also pass a <code>ModelDefinition</code> object directly to the <code>Simulation</code> constructor. In that case, a new <code>Model</code> would be instantiated automatically.</p><p>The initialization step is straightforward:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; init_air = C172.TrimParameters(); #straight and level, default airspeed and altitude</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Sim.init!(sim, init_air)</code></pre><p>What next? You may recall how during <a href="../../tutorial01/tutorial01/#Interactive-Simulation">interactive simulation</a> we used the <em>Aircraft &gt; Avionics &gt; Flight Control</em> GUI panel to control the aircraft. That panel belongs to the <code>mdl.aircraft.avionics.ctl</code> node, which implements the flight control laws for the <code>Cessna172Xv1</code> aircraft. Let&#39;s retrieve its input <code>struct</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; u_ctl = mdl.aircraft.avionics.ctl.u;</code></pre><p>It is this <code>struct</code> that the control inputs in <em>Aircraft &gt; Avionics &gt; Flight Control</em> map to. Here, we will be writing to it directly. Let&#39;s inspect its fields:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; shf(u_ctl)</code><code class="nohighlight hljs ansi" style="display:block;">Flight.FlightAircraft.C172.C172X.C172XControl.ControllerU:
   eng_start::Bool = false
   eng_stop::Bool = false
   mixture::Ranged{Float64, 0.0, 1.0} = Ranged{Float64, 0.0, 1.0}(0.5)
   flaps::Ranged{Float64, 0.0, 1.0} = Ranged{Float64, 0.0, 1.0}(0.0)
   brake_left::Ranged{Float64, 0.0, 1.0} = Ranged{Float64, 0.0, 1.0}(0.0)
   brake_right::Ranged{Float64, 0.0, 1.0} = Ranged{Float64, 0.0, 1.0}(0.0)
   throttle_axis::Ranged{Float64, 0.0, 1.0} = Ranged{Float64, 0.0, 1.0}(0.6504000622953328)
   aileron_axis::Ranged{Float64, -1.0, 1.0} = Ranged{Float64, -1.0, 1.0}(0.012482497186299011)
   elevator_axis::Ranged{Float64, -1.0, 1.0} = Ranged{Float64, -1.0, 1.0}(-0.24248140495200216)
   rudder_axis::Ranged{Float64, -1.0, 1.0} = Ranged{Float64, -1.0, 1.0}(0.006921629149339786)
   throttle_offset::Ranged{Float64, 0.0, 1.0} = Ranged{Float64, 0.0, 1.0}(0.0)
   aileron_offset::Ranged{Float64, -1.0, 1.0} = Ranged{Float64, -1.0, 1.0}(0.0)
   elevator_offset::Ranged{Float64, -1.0, 1.0} = Ranged{Float64, -1.0, 1.0}(0.0)
   rudder_offset::Ranged{Float64, -1.0, 1.0} = Ranged{Float64, -1.0, 1.0}(0.0)
   vrt_gdc_mode_req::Flight.FlightAircraft.C172.C172X.C172XControl.VerticalGuidanceMode = vrt_gdc_off
   hor_gdc_mode_req::Flight.FlightAircraft.C172.C172X.C172XControl.HorizontalGuidanceMode = hor_gdc_off
   lon_ctl_mode_req::Flight.FlightAircraft.C172.C172X.C172XControl.LonControlMode = lon_direct
   lat_ctl_mode_req::Flight.FlightAircraft.C172.C172X.C172XControl.LatControlMode = lat_direct
   EAS_ref::Float64 = 50.00000000000001
   q_ref::Float64 = 0.0
   θ_ref::Float64 = 0.023552515371104785
   clm_ref::Float64 = -4.440892098500626e-16
   p_ref::Float64 = 0.0
   φ_ref::Float64 = 0.0008933160324874771
   χ_ref::Float64 = -2.1037900026700017e-5
   β_ref::Float64 = 0.0
   h_ref::Float64 = 1050.0
   h_datum::Flight.FlightAircraft.C172.C172X.C172XControl.AltDatum = ellipsoidal</code></pre><p>Note how the trim function, invoked by the <code>Sim.init!</code> call, has already set the primary control inputs (<code>throttle_axis</code>, <code>elevator_axis</code>, <code>aileron_axis</code> and <code>rudder_axis</code>) to the values required by the trimmed flight condition. Also, the longitudinal and lateral control mode inputs (<code>lon_ctl_mode_req</code> and <code>lat_ctl_mode_req</code>) are set to their direct values. This bypasses all control loops, preserving the aircraft&#39;s natural dynamic response, which is what we want here.</p><p>Let&#39;s first advance the <code>Simulation</code> a few seconds without perturbing the trim equilibrium. To do so, we use the <code>Sim.step!</code> method, which essentially wraps the one from <code>DifferentialEquations.jl</code>&#39;s <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/integrator/#CommonSolve.step!">integrator interface</a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Sim.step!(sim, 5) #advance the simulation 5 seconds</code></pre><p>Now, to apply the elevator doublet, we can either modify the <code>elevator_axis</code> input directly or, more conveniently, use <code>elevator_offset</code> instead. Here&#39;s how to do it:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; u_ctl.elevator_offset = 0.1; #10 percent positive offset</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Sim.step!(sim, 2) #advance 2 seconds</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u_ctl.elevator_offset = -0.1; #10 percent negative offset</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Sim.step!(sim, 2) #advance 2 seconds</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u_ctl.elevator_offset = 0.0; #return to trim position</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Sim.run!(sim) #run the Simulation to completion (t_end)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36"><span class="sgr1">[ Info: </span></span>Simulation: Starting on thread 1...
<span class="sgr36"><span class="sgr1">[ Info: </span></span>Simulation: Finished in 0.085280152 seconds
Task (done) @0x00007f400dce1140</code></pre><p>The data logged by a <code>Simulation</code> are the values of its root <code>Model</code>&#39;s output. By default, these are saved at every integration step, but different saving intervals can be specified. The easiest way to retrieve and handle this data is through the <code>TimeSeries</code> type:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ts = TimeSeries(sim)</code><code class="nohighlight hljs ansi" style="display:block;">TimeSeries{@NamedTuple{aircraft::@NamedTuple{vehicle::Flight.FlightLib.AircraftBase.VehicleY{@NamedTuple{aero::Flight.FlightAircraft.C172.AeroY, ldg::@NamedTuple{left::@NamedTuple{steering::Flight.FlightLib.Land...}(...)</code></pre><p>A <code>TimeSeries</code> object lets you inspect the properties of its underlying data type and generate another <code>TimeSeries</code> object for any of these properties. This is particularly convenient when dealing with large, deeply nested types, as <code>Model</code> outputs often are. Let&#39;s see a few examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; propertynames(ts)</code><code class="nohighlight hljs ansi" style="display:block;">(:aircraft,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; propertynames(ts.aircraft)</code><code class="nohighlight hljs ansi" style="display:block;">(:vehicle, :avionics)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; propertynames(ts.aircraft.vehicle)</code><code class="nohighlight hljs ansi" style="display:block;">(:systems, :kinematics, :dynamics, :airflow)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ts_kin = ts.aircraft.vehicle.kinematics</code><code class="nohighlight hljs ansi" style="display:block;">TimeSeries{KinData}(...)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ts_sys = ts.aircraft.vehicle.systems</code><code class="nohighlight hljs ansi" style="display:block;">TimeSeries{@NamedTuple{aero::Flight.FlightAircraft.C172.AeroY, ldg::@NamedTuple{left::@NamedTuple{steering::Flight.FlightLib.LandingGear.NoSteeringY, braking::Flight.FlightLib.LandingGear.DirectBrakingY, strut::...}(...)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ts_ω = ts_kin.ω_wb_b #angular velocity, Wander frame to Body frame (rad/s)</code><code class="nohighlight hljs ansi" style="display:block;">TimeSeries{StaticArraysCore.SVector{3, Float64}}(...)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ts_θ = ts_kin.e_nb.θ #pitch angle, NED frame to Body frame (rad)</code><code class="nohighlight hljs ansi" style="display:block;">TimeSeries{Float64}(...)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ts_α = ts_sys.aero.α #angle of attack (rad)</code><code class="nohighlight hljs ansi" style="display:block;">TimeSeries{Float64}(...)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; _, ts_q, _ = get_components(ts_ω); #pitch rate (rad/s)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ts_el_cmd = ts_sys.act.elevator.cmd[4 .&lt;= get_time(ts) .&lt; 10] #elevator command</code><code class="nohighlight hljs ansi" style="display:block;">TimeSeries{Ranged{Float64, -1.0, 1.0}}(...)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ts_el_pos = ts_sys.act.elevator.pos[4 .&lt;= get_time(ts) .&lt; 10] #elevator position</code><code class="nohighlight hljs ansi" style="display:block;">TimeSeries{Ranged{Float64, -1.0, 1.0}}(...)</code></pre><p><code>Plots.jl</code> recipes are available for many common <code>TimeSeries</code> subtypes, so plotting is usually straightforward:</p><pre><code class="language-julia hljs">import Plots
using LaTeXStrings

#TimeSeries{&lt;:Ranged} recipe
Plots.plot(ts_el_cmd; plot_title=&quot;Elevator Response&quot;, label = &quot;Command&quot;)
Plots.plot!(ts_el_pos; label = &quot;Position&quot;)</code></pre><img src="812bafed.svg" alt="Example block output"/><pre><code class="language-julia hljs">#TimeSeries{&lt;:AbstractVector{&lt;:Real}} recipe
Plots.plot(ts_ω; plot_title=&quot;Angular Velocity&quot;, ylabel=L&quot;$\omega \ (rad/s)$&quot;)</code></pre><img src="1d16923f.svg" alt="Example block output"/><pre><code class="language-julia hljs">#TimeSeries{Real} recipe
Plots.plot(ts_α; plot_title=&quot;AoA vs Pitch Angle&quot;, ylabel=L&quot;$\alpha, \ \theta \ (rad)$&quot;, label=&quot;AoA&quot;)
Plots.plot!(ts_θ; label = &quot;Pitch Angle&quot;)</code></pre><img src="a2cc677d.svg" alt="Example block output"/><p>Function <code>make_plots</code> generates a batch of useful plots from a specific <code>TimeSeries</code> subtype. Out of the box, it is implemented for <code>TimeSeries{KinData}</code>, <code>TimeSeries{DynData}</code> and <code>TimeSeries{AirData}</code>, so for example you can do:</p><p>Plots.default(:size, (900, 600)) display(t3d)</p><p>You can batch save them with save_plots</p><p>Don&#39;t mention recursive... Proceeds recursively down the <code>Model</code> hierarchy.</p><hr/><h3 id="Automating-Simulation-Control-With-User-Callbacks"><a class="docs-heading-anchor" href="#Automating-Simulation-Control-With-User-Callbacks">Automating Simulation Control With User Callbacks</a><a id="Automating-Simulation-Control-With-User-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Automating-Simulation-Control-With-User-Callbacks" title="Permalink"></a></h3><p>Introduce callback for doublet.</p><p>Then move on to complex multi-phase flight. Ground init, startup, take-off, spiral climb until h condition</p><p>world.ac.avionics.ctl.u.lon<em>ctl</em>mode<em>req |&gt; typeof using .C172X.C172XControl: lon</em>direct, lon_sas</p><hr/><p>These values come from fields in the <code>ModelDefinition</code> subtype that <em>are not</em>   themselves <code>ModelDefinition</code>s.     These <code>Model</code>s are built from those fields in the <code>ModelDefinition</code> subtype that <em>are</em> themselves   <code>ModelDefinition</code>s.</p><p>When the <code>Model</code> constructor is called on a <code>ModelDefinition</code>, those fields that are themselves <code>ModelDefinition</code>s are also turned into <code>Model</code>s, and they become children in the parent <code>Model</code>&#39;s hierarchy. Therefore, within <code>submodels</code> we will find <code>Model</code>s created from the <code>Cessna172Xv1</code>, <code>SimpleAtmosphere</code> and <code>HorizontalTerrain</code> objects we passed to the <code>SimpleWorld</code> constructor.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mdl.submodels</code><code class="nohighlight hljs ansi" style="display:block;">(aircraft = Model{Flight.FlightLib.AircraftBase.Aircraft{Flight.FlightLib.AircraftBase.Vehicle{Flight.FlightAircraft.C...}(...), atmosphere = Model{SimpleAtmosphere{TunableSeaLevel, TunableWind}}(...), terrain = Model{HorizontalTerrain}(...))</code></pre><p>The <code>ModelDefinition</code> subtype is preserved as the <code>Model</code>&#39;s first type parameter. It serves both as the <code>Model</code>&#39;s primary identifier and as a dispatch mechanism when calling <code>Model</code> update functions.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 15 August 2025 20:27">Friday 15 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
